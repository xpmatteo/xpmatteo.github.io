<!DOCTYPE html>
<html>
  
<!-- Mirrored from matteo.vaccari.name/so/diario by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 24 Sep 2021 09:56:57 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=utf-8" /><!-- /Added by HTTrack -->
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Matteo Vaccari &mdash; Diario per Sistemi Operativi II, a.a. 2007/8</title>
    <link rel="stylesheet" href="../stylesheets/matteo.css" />
  </head>
  <body>
    <h2>Diario per Sistemi Operativi II, a.a. 2007/8</h2>
    
      <h3 class="notopmargin">
        <a href="../index.html">Matteo Vaccari</a>
        &gt;
        <a href='../so.html'>Sistemi Operativi</a>
      </h3>
    

    
<div class="ahem">

<p>
Tutte le letture e gli esercizi che non siano esplicitamente marcati come
"facoltativi" sono parte del programma di esame.
</p>

  <p>
  I lucidi che potete trovare in questa pagina <strong>non sono
  un sostituto per il libro di testo</strong> o per gli altri materiali
  che vi segnalo.  I lucidi <em>non contengono un discorso
  completo</em>, ma solo una traccia, che è comprensibile soltanto nel
  contesto di quello che dico a lezione quando li proietto.  
  </p>

  <p>Lo scopo di
  rendervi disponibili le slide è di lasciarvi una <em>traccia</em> dei
  discorsi che abbiamo fatto a lezione.  Per chi non era presente,
  l'unica utilità delle slide è come <strong>promemoria</strong> degli
  argomenti che sono stati trattati.
  </p>

  <p>
  Insomma, ripeto: <strong>non limitate il vostro studio ai lucidi!</strong>  
  </p>
</div>

<br />
<br />

<ul>  
  <li>
    
28-04-2008
 Lezione 0 <br />
    
Gestione della memoria: metodi semplici.  Richiami di linguaggio C: stack, heap e globals.  Uso dei puntatori.  Makefile

    <ul><li>
Tanenbaum 4.1 (Basic memory management), 4.2 (Swapping)
</li><li>
<a href="slides/handout-slides12.pdf">lucidi</a> (aggiornati e corretti!! 30/4/08)
</li><li>
Lettura facoltativa: E.W.Dijkstra, <a href="files/ewd1303.pdf.gz">My recollections of operating system design</a>


</li></ul>
    
    <br />
  </li>
  <li>
    
05-05-2008
 Lezione 1 <br />
    
Memoria virtuale paginata.  Algoritmi di rimpiazzo.  Località dei processi, working set.  

    <ul><li>
Tanenbaum 4.3 (Virtual memory), 4.4 (Page replacement algorithms) (tranne 4.4.6)
</li><li>
<a href="slides/handout-slides13.pdf">lucidi</a> 
</li><li>
Esercizio svolto in laboratorio: <a href="files/ese20080505.txt">Una semplice shell</a>
</li><li>
Lettura facoltativa: <a href="http://kerneltrap.org/node/3148">intervista ad Andrea Arcangeli</a>, autore del gestore della memoria virtuale in Linux 2.4

</li></ul>
    
    <br />
  </li>
  <li>
    
12-05-2008
 Lezione 2 <br />
    
Località dei processi, working set.  Memoria segmentata.

    <ul><li>
Tanenbaum 4.5. Design Issues for Paging Systems (solo 4.5.1 e 4.5.2).  4.6. Segmentation
</li><li>
<a href="slides/handout-slides14.pdf">lucidi</a> 
</li><li>
Esercizio svolto in laboratorio: <a href="files/ese20080505.txt">Una semplice shell</a>.  Soluzione per il <a href="files/ese20080505-v0.txt">primo livello</a> e soluzione parziale per il <a href="files/ese20080505-v1.zip">secondo livello</a>.

</li></ul>
    
    <br />
  </li>
  <li>
    
15-05-2008
 Lezione 3 <br />
    
Il Process Manager di Minix. Implementazione di malloc(3).  Gestione della memoria in Linux.

    <ul><li>
Tanenbaum 4.7. Overview of the MINIX 3 Process Manager (escluso 4.7.7, Signal Handling)
</li><li>
<a href="slides/handout-slides15.pdf">lucidi</a> 
</li><li>
Jonathan Bartlett, <a href="http://www-128.ibm.com/developerworks/linux/library/l-memory/">Inside memory management</a>
</li><li>
Poul-Henning Kamp, <a href="http://varnish.projects.linpro.no/wiki/ArchitectNotes">Varnish Architect Notes</a>
</li><li>
Leggere il manuale dei comandi vmstat(1), top(1)
</li><li>
</li><li> Esercizio: verificare la differenza di performance <a href="files/matrix.c">fra programmi che
accedono a una grande matrice</a> (più grande della memoria fisica) per
righe piuttosto che per colonne.  Spiegare il <em>perché</em> della
differenza.  Verificare per mezzo del comando /usr/bin/time 
<ol><li>il tempo di esecuzione</li><li>il numero di page
fault</li></ol> Monitorare per mezzo di top(1) il comportamento del
processo e la quantità di memoria disponibile nel sistema.

</li></ul>
    
    <br />
  </li>
  <li>
     
19-05-2008
 Lezione 4 <br />
    
File system.  Operazioni su file e directory.   Strutture dati del kernel di
Unix relative a file aperti e processi.

    <ul><li>
Tanenbaum 5.1 (Files), 5.2 (Directories)
</li><li>
Studiare le pagine di manuale di open(2), read(2), write(2), close(2),
dup(2), lseek(2)
</li><li>
<a href="slides/handout-slides16.pdf">lucidi</a> 
</li><li>
Esercizio: scrivere un programma che redirige il proprio standard
output su un file "/tmp/pippo", e verificare che ogni successiva
operazione di output (es.\ con printf(3)) modifica il file
</li><li>
Esercizio: estendere il programma precedente; dopo la redirezione
dell'output, eseguire una fork(2) seguita da wait(2) nel genitore e da
una execve(2) nel figlio; il figlio deve eseguire il comando "ls".
Verificare che anche questo output viene scritto nel file /tmp/pippo
</li><li>
Esercizio: estendere il programma precedente; deve ridirigere sia
standard output che standard input sullo stesso file /tmp/pippo.  Il
comando "ls" deve essere eseguito con un argomento corretto e uno
sbagliato, in modo che produca output sia su standard input che su
standard output  (es.\ "ls /tmp dflkjhdlfjkh").  Verificare che
entrambi gli output finiscono nel file /tmp/pippo
</li><li>
Esercizio: estendere la mini-shell presentata tempo fa a lezione per
implementare i meccanismi di redirezione.  Iniziare con "&gt;", poi implementare gli
altri: "&lt;", "&gt;&gt;", "2&gt;", "2&gt;&amp;1", "&lt;&lt;", "|".  Gli ultimi due sono più
difficili.  Limitarsi al caso di una pipe fra due soli comandi.

</li></ul>
    
    <br />
  </li>
  <li>
    

22-05-2008
 Lezione 5 <br />
    
Pipe.  Directory.  Implementazione dei filesystem.  Hard link e soft
link.  I filesystem di Unix: V7, FFS, Ext2.  

    <ul><li>
Tanenbaum 5.3 (File system implementation)
</li><li>
<a href="slides/handout-slides17.pdf">lucidi</a>
</li><li>
Studiare il manuale delle chiamate di sistema pipe(2) e dup(2)
</li><li>
Esercizio: scrivere un programma che stampa la tabella dei quadrati,
cubi e radici quadrate degli interi da 0 a 1024.  Vogliamo evitare che
l'output del programma scorra troppo velocemente sullo schermo; il programma deve allora
invocare il programma "less" e passare tutto il suo output a "less"
per mezzo di una pipe.
</li><li>
Esercizio: eseguire l'esercizio riportato nei lucidi
</li><li>
Esercizio: la <a href="files/myshell-v2.zip">mini-shell realizzata in laboratorio</a> contiene un errore; non esegue correttamente i comandi in background.  Correggere l'errore.  
</li><li>
Lettura facoltativa: Andrew Tanenbaum, <a
href="http://www.cs.vu.nl/~ast/brown/">Some Notes on the "Who wrote
Linux" Kerfuffle, Release 1.5</a> su una controversia sorta qualche anno fa sulla paternità di Linux, e la verosimiglianza del fatto che uno studente possa scrivere "da solo" il nucleo di un clone di Unix.
</li><li>
Lettura facoltativa: Alessandro Rubini, <em>Filesystem su Linux: uno sguardo ai moduli e al kernel</em>, Linux&amp;C., anno 10, numero 63 (in edicola in questi giorni).  In alternativa, Alessandro Rubini, <a href="http://www.linux.it/~rubini/docs/filesystem/filesystem.html" title="I filesystem">I filesystem</a> si può scaricare liberamente.  Rubini è il miglior divulgatore esistente del kernel di Linux.  In questo articolo illustra &ndash;con il codice&ndash; il funzionamento di un filesystem Linux particolarmente semplice.   Anche il suo <a href="http://lwn.net/Kernel/LDD3/">libro sui device driver</a> è una introduzione accessibile e interessante alla programmazione del kernel di Linux.  
</li><li>
Lettura facoltativa: <a href="http://research.sun.com/technical-reports/1994/abstract-29.html">A Note on Distributed Computing</a> spiega perché il fatto che NFS presenti la stessa interfaccia di programmazione di un filesystem locale è stato un errore.


</li></ul>
    
    <br />
  </li>
  <li>
    

26-05-2008
 Lezione 6 <br />
    
Linux Ext2.  Virtual file system.  Network file system (NFS).  Memory-mapped files.

    <ul><li>
<a href="slides/handout-slides18.pdf">lucidi</a>
</li><li>
Studiare il manuale delle chiamate di sistema mmap(2), munmap(2) e naturalmente read(2), write(2), open(2) e close(2).
</li><li>
Esercizio svolto in laboratorio: 
<ul>
<li>Implementare un programma che copia un file in un altro tramite read(2) e write(2).</li>  
<li>Scrivere un programma che mappa un file in memoria, e stampa tutti i caratteri del file, uno per riga.  Ad esempio, se il file /tmp/pippo contiene la stringa "ciao", deve stampare
  <pre>
    Il carattere alla posizione 0 è 'c'
    Il carattere alla posizione 1 è 'i'
    Il carattere alla posizione 2 è 'a'
    Il carattere alla posizione 3 è 'o'
  </pre>
  Lo pseudocodice del programma è
  <pre>
    main(argc, argv)
      /* il nome del file è passato come argomento: si trova in argv[1] */
      apri il file con open(2)
      trova la lunghezza del file con fstat(2)
      mappa il file in memoria con mmap(2)
      itera su tutti i caratteri del file
  </pre>
</li>
<li>Implementare la copia con mmap(2) e write(2).  Lo pseudo codice si trova nei lucidi</li>
<li>Implementare la copia con mmap(2) e memcpy(3).  Lo pseudo codice è
  <pre>
    main(argc, argv)
      /* il nome del file di input è passato come argomento: si trova in argv[1] */
      /* il nome del file di output è passato come argomento: si trova in argv[2] */
      apri il file di input con open(2)
      crea il file di output con open(2)
      trova la lunghezza del file di input con fstat(2)
      estendi la lunghezza del file di output con ftruncate(2) per farla uguale al file di input
      mappa entrambi i file in memoria con mmap(2)
      copia l'input sull'output con memcpy(3)
      chiudi i due file
  </pre>
  </li>
</ul>
</li><li> Esercizio: misura la differenza di performance fra le varie maniere di fare la copia

</li><li> Esercizio: scrivere un programma che copia un file usando read(2) e
write(2).  Verificare la differenza di performance al variare della
dimensione del buffer; provare con 8192, 4096, 100, 10, 1.  Spiegare
il <em>perché</em> della differenza.
</li><li> Esercizio: riscrivere il programma dell'es. precedente con fread(3)
e fwrite(3).  C'è ancora differenza al variare della dimensione del
buffer?  Perché?

</li></ul>
    
    <br />
  </li>
  <li>
    
30-05-2008
 Lezione 7 <br />
    
Controllo dell'integrità di un filesystem.  Transazioni.  Journaled
file systems.  Reiserfs. 

    <ul><li>
Tanenbaum tutto 5.3 (File system implementation)
</li><li>
<a href="slides/handout-slides19.pdf">lucidi</a> 

</li><li> Lettura NON facoltativa: sezioni 7.1 - 7.6 di <a
href="files/practical-file-system-design.pdf.gz">Practical File System
Design</a> di Dominic Giampaolo

</li><li> Lettura facoltativa:  
  <a href='http://research.sun.com/techrep/1994/abstract-29.html'>A Note on Distributed Computing</a> su perché
  l'interfaccia di NFS non funziona bene come si vorrebbe

</li><li> Lettura facoltativa:  
  <a href='http://www.kuro5hin.org/story/2003/8/9/172159/7912'>Why a
  New Filesystem Matters</a> su ReiserFS

</li><li>
Letture facoltative:
La serie di articoli di Daniel Robbins "Advanced filesystem implementor's guide"
<ul>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs.html">Part I</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs2.html">Part II</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs3.html">Part III</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs4.html">Part IV</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs5.html">Part V</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs6/">Part VI</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs7.html">Part VII</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs8.html">Part VIII</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs9.html">Part IX</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs10.html">Part X</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs11.html">Part XI</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs12/">Part XII</a></li>
<li><a href="http://www-106.ibm.com/developerworks/linux/library/l-fs13/">Part XIII</a></li>
</ul>

</li><li> Laboratorio: ancora sul programma che copia un file in un altro.
<pre>
  Scrivere un file che copia un file in un altro

  Pseudocodice
    apre il primo file (argv[1])
    crea il secondo file (argv[2])
    legge i primi 8Kb con read(2)
    copia i byte con write(2)
    chiude entrambi i file
    exit(0)

  Test:
   ./copia-con-read-write /etc/passwd /tmp/copia-di-passwd
   diff /etc/passwd /tmp/copia-di-passwd
   (se "diff" dice qualcosa vuol dire che i file non sono uguali)

  == Secondo livello==  usare un ciclo per copiare a colpi di 8KB file di dimensioni arbitrarie.

  Test:
   n=0; while [ $n -lt 1000000 ]; do echo $n >> /tmp/bigfile; n=$(($n + 1)); done
   ./copia-con-read-write /tmp/bigfile /tmp/copia-di-bigfile
   diff /tmp/bigfile /tmp/copia-di-bigfile  
</pre>


</li></ul>
    
    <br />
  </li>
  <li>
    
06-06-2008
 Lezione 8 <br />
    
Crittografia simmetrica.  Funzioni botola, digest.  Autenticazione e autorizzazione.
Autenticazione in Unix.  Crittografia asimmetrica.  Firme digitali.  

    <ul><li>
Tanenbaum 5.4 (Security), 5.5 (Protection mechanisms)
</li><li>
<a href="slides/handout-slides20.pdf">lucidi</a> 
</li><li>
Lettura <em>non</em> facoltativa: capitolo 1 di <a href="files/IntroToCrypto.pdf.gz">An Introduction to Cryptography</a> di Philip Zimmermann, autore di PGP
</li><li>
Letture facoltative sulla crittografia:
<ul>
<li>Simon Singh, <em>The code book</em>. Una divertente introduzione
divulgativa
</li>
<li> Per chi voglia approfondire seriamente l'argomento, consiglio i
 seguenti libri di  Bruce Schneier:
 <ul>
  <li><em>Practical Cryptography</em></li>
  <li><em>Secrets and Lies</em></li>
 </ul>
</li>
<li>Andrew Hodges, <em>Alan Turing, The Enigma</em>.  È un ottima
biografia, che ha fatto rinascere l'interesse per la figura di Turing
e per il lavoro dei criptoanalisti alleati nella Seconda Guerra
Mondiale</li>
<li>Neal Stephenson, <em>Cryptonomicon</em>.  Un romanzo a sfondo
storico; contiene fra l'altro dei bellissimi ritratti di
crittografi/crittoanalisti</li>
<li>Edgar Allan Poe, 
  <a href="http://www.google.it/search?q=the+gold+bug"><em>The Gold-Bug</em></a> 
  (<a href="http://web.tiscali.it/manuel_ger/ita/bug_ita.htm">Lo
scarabeo d'oro</a>).  Questo racconto contiene un semplice esempio di
criptoanalisi</li>
<li>Sui modelli tradizionali (Bell- La Padula) di sicurezza, un'ottima
lettura è <a
href='http://mitpress.mit.edu/catalog/item/default.asp?tid=8635&amp;ttype=2'>Mechanizing
Proof</a>, di Donald MacKenzie</li>
</ul>
</li><li>
Laboratorio:
<pre>
== Primo livello ==

Scrivere un programma che accetta come argomento un nome di file e descrive i metadati del file, come da questo esempio:

$ ./lista /etc/passwd
Type Mode  N.links Uid Gid Size Name
file 0644  1       0   1   1932 /etc/passwd
$
$ ./lista blablabla
blablabla: No such file or directory

== Secondo livello ==

Se il nome di file rappresenta una directory, listare il contenuto di essa

$ ./lista /etc
Type Mode  N.links Uid Gid Size Name
file 0644  1       0   1   1932 csh.login
dir  0644  1       0   1   1932 cups
file 0644  1       0   0    388 passwd
file 0644  1       0   112 1234 profile


== Terzo livello == 

Se viene passato l'argomento "-R", listare ricorsivamente le sottodirectory

$ ./lista -R /etc
directory /etc:
Type Mode  N.links Uid Gid Size Name
file 0644  1       0   1   1932 csh.login
dir  0644  1       0   1   1932 cups
file 0644  1       0   0    388 passwd
file 0644  1       0   112 1234 profile

directory cups:
Type Mode  N.links Uid Gid Size Name
file 0644  1       0   112 1234 printers.conf
$
</pre>


</li></ul>
    
    <br />
  </li>
  <li>
    
09-06-2008
 Lezione 9 <br />
    
Software nocivi: back door, logic bomb, Trojan horse, worm, virus.  Il
Morris Worm.  La back door di Thompson.  Buffer overflow.  

    <ul><li>
<a href="slides/handout-slides21.pdf">lucidi</a> 
</li><li>
Ken Thompson, <a href="http://cm.bell-labs.com/who/ken/trust.html">Reflections on Trusting Trust</a>; 1983 Turing Award lecture.
</li><li>
Letture facoltative:
<ul>
<li><a href="files/p678-spafford.pdf.gz">The Internet Worm: Crisis and Aftermath</a></li>
<li><a href="http://www.itworld.com/Sec/2202/LWD010404vcontrol1/">On
getting cracked and recovering with NMAP</a></li>
<li> la pagina di manuale di nmap(1)</li>
<li>Cliff Stoll, <em>The Cuckoo's Egg</em>.  Un resoconto della lotta
di un operatore contro un cracker.  La storia è vera, e vengono descritti
diversi personaggi del mondo della sicurezza informatica; notevole il
ritratto di Robert&nbsp;Morris&nbsp;Senior.</li>
</ul> 



</li></ul>
    
    <br />
  </li>
  <li>
    
11-06-2008
 Lezione 10 <br />
    
Signal.  Server programming.  FIFOs.

    <ul><li>
<a href="slides/handout-slides22.pdf">lucidi</a> 
</li><li>
Esercizio: implementare un processo che intercetta SIGINT (vedi <a href="esercizi.html">esercizi</a>, n. 7)
</li><li>
Esercizio: implementare un servizio echo client-server con FIFO (vedi <a href="esercizi.html">esercizi</a>, n. 8)
</li><li>
Lettura facoltativa: <a href="http://citeseer.ist.psu.edu/ritchie74unix.html">The Unix Time-Sharing System (1984)</a> di Dennis Ritchie, Ken Thompson.  Il classico articolo che descrive Unix.
</li><li>
Lettura facoltativa: <a href="http://cm.bell-labs.com/who/dmr/hist.html" title="Early Unix history and evolution">The Evolution of the Unix Time-Sharing System</a> di Ken Thompson 
</li><li>
Lettura facoltativa: Richard P. Gabriel, <a href="http://www.dreamsongs.com/WIB.html">Lisp: Good News, Bad News,
How to Win Big</a>.  Anche se l'argomento principale è il linguaggio
di programmazione Lisp, la seconda parte di questo articolo discute in
termini molto provocatori la filosofia ingegneristica che sta alla
base di Unix.  Di Gabriel c'è anche <a
href="http://www.dreamsongs.com/WorseIsBetter.html"> un articolo che
rivede questo saggio in retrospettiva </a>

</li></ul>
    
    <br />
  </li>
  <li>
    
12-06-2008
 Lezione 11 <br />
    
I principi di design di Unix.  Soluzione di un tema d'esame.

    <ul><li>
<a href="slides/handout-slides23.pdf">lucidi</a> 
</li><li>
Lettura facoltativa: <a href="http://www.catb.org/~esr/writings/taoup/html/" title="The Art of Unix Programming">the art of unix programming</a> di Eric Steven Raymond.


</li></ul>
    
    <br />
  </li>
</ul>


    <div id="footer">
      <address>
        <script type="text/javascript">eval(unescape('%64%6f%63%75%6d%65%6e%74%2e%77%72%69%74%65%28%27%3c%61%20%68%72%65%66%3d%22%6d%61%69%6c%74%6f%3a%76%61%63%63%61%72%69%40%70%6f%62%6f%78%2e%63%6f%6d%22%3e%76%61%63%63%61%72%69%40%70%6f%62%6f%78%2e%63%6f%6d%3c%2f%61%3e%27%29%3b'))</script>
      </address>
    </div>
    
  </body>

<!-- Mirrored from matteo.vaccari.name/so/diario by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 24 Sep 2021 09:56:58 GMT -->
</html>