+++
title = 'AI-assisted modernization of Java, part IV'
slug = 'ai-assisted-modernization-of-java-part-iv'
date = 2025-10-15T16:59:35+02:00
tags = [
    "AI",
    "java",
    "modernization",
]
draft = true
+++

<style>
pre {
  overflow-x: auto;
  white-space: pre;
}
</style>

Disclaimer: This series of articles is about solving an exercise; actual work is going to be more difficul than this. However, by practicising like this, I believe **we can build skills** that will enable us to deal with the more complicated challenges in real life

Setup:

- Claude Code with Claude Sonnet 4.5 (new!)
- My global CLAUDE.md is a variant of [Harper Reed's](https://github.com/harperreed/dotfiles/blob/35c2d5508f36b7ad6a845f605c12bcdb16fb15a3/.claude/CLAUDE.md "dotfiles/.claude/CLAUDE.md at 35c2d5508f36b7ad6a845f605c12bcdb16fb15a3 · harperreed/dotfiles · GitHub")
- The [repo for the exercise on Github](https://github.com/xpmatteo/app-modernization-plants-by-websphere-jee6 "GitHub - xpmatteo/app-modernization-plants-by-websphere-jee6: AI-assisted porting a Java app from JEE to Spring Boot")


# Converting the product page

## Brief recap

What we're doing here: we're seeing how AI helps in the modernization of a Java application; the modernization consists in moving from an obsolete/deprecated technology, namely <abbr title="Java Enterprise Edition">JEE</abbr>, to something easier to maintain, in this case, Spring Boot. The starting point is [a WebSphere demo application](https://github.com/IBMAppModernization/app-modernization-plants-by-websphere-jee6 "GitHub - IBMAppModernization/app-modernization-plants-by-websphere-jee6: Java Enterprise Edition 6 version of the Plants By Websphere Sample modified to run in a Liberty container") that has been used in the past for another modernization exercise.

Our strategy is to create a fresh Spring Boot application in a new module in our repo, and move the interesting bits of the application from the old JEE module to the new Spring Boot module.  Oh, and the other important bit of the strategy is that we're focusing on the most important user journey: buying something.  The journey is, in brief:

1. Land on the home page
2. Click on the "Bonsai tree" link -> the product page opens
3. Click on the "Add to cart" button -> the Shopping Cart page opens
4. Click on "Checkout now" -> if you are logged in, the Checkout page opens.  If you're not, the login page opens; but we'll assume that we're logged in, because we want to focus on the smallest valuable journey
5. We fill in the order data in the Checkout page, and click on "Continue" -> the "Review your order" page opens
6. We click on "Submit Order" -> hopefully, we should wee a confirmation page.  In my test, I see a javax.ejb.NoSuchEJBException; I don't know if this depends on my setup being wrong, or if the app really has a bug. We'll get to that when we get there.

In [part III](/posts/ai-assisted-modernization-of-java-part-iii/) we dealt with step 1 of the journey: we ported the home page of the application, which is more or less a static page, even though it's generated by a template.  We also wrote a characterization test for it.  In this installment, we work on step 2.

## The task

In the legacy application, when we click on the Bonsai Tree link, the application executes a POST. This is because it's using the JSF framework, which does this kind of things. In our modernized application, we change this to a GET, because it's the right thing to do in this case.  The link points to `/product?itemID=T0003`, and if we run this in the Spring Boot app, we get a 404.  Today's job is to fix this URL to produce the correct product page, pulling product information from the DB.  In fact, the test DB contains this data for the Bonsai Tree:

```sql
mysql> select * from INVENTORY where INVENTORYID = 'T0003'\G
*************************** 1. row ***************************
 INVENTORYID: T0003
        NAME: Bonsai
     HEADING: Tabletop Fun
 DESCRIPTION: Bonsais are great miniature replicas of your favorite yard tree. They can be indoors or out -- and their size makes them perfect for tabletop decoration.
     PKGINFO: 0.5 gallon mature tree
       IMAGE: trees_bonsai.jpg
    IMGBYTES: NULL
       PRICE: 30
        COST: 12
    CATEGORY: 2
    QUANTITY: 100
       NOTES: NOTES and stuff
    ISPUBLIC: 1
MINTHRESHOLD: 0
MAXTHRESHOLD: 0
1 row in set (0.004 sec)
```

The legacy page looks like this:

<figure style="margin: 0 auto; display: block; width: 80%">
  <img src="product-page.jpg" alt="The Bonsai Tree product page" style='border: 1px solid black'>
  <figcaption>The Bonsai Tree product page
  </figcaption>
</figure>

## Planning

Let's get the AI to the task. We start Claude Code (CC), we put it in *plan mode* and ask:

<blockquote>
  <b>check out the product page at http://localhost:9080/product.jsf?itemID=T0003.  We want to port it to Spring Boot; currently
Spring Boot returns 404 at http://localhost:8080/product?itemID=T0003.  What are our options?</b>
</blockquote>

(It turns out that the legacy app also supports opening the product page with GET. This is helpful.)  Given that I have the Puppetteer MCP server installed, Claude examines both urls.

**The Ask For Options heuristic**: it's good to start new tasks in plan mode, so that CC knows that we don't want it to rush to code. It's also good to ask for options, so that we get the model to look for more than one way to achieve what we ask it. Here's CC's proposal:

<blockquote>
  Porting Product Page to Spring Boot - Options Analysis

  Current Situation

  - Legacy app (JSF): Uses /product.jsf?itemID=T0003 with JSF backing bean pattern
  - Spring Boot: Returns 404 for /product?itemID=T0003 (no controller/route exists yet)
  - The promo page already links to /product?itemID=... (lines 130, 142, 154 in promo.mustache)

  Architecture Pattern Identified

  Legacy (JSF/EJB):
  - JSF view (product.xhtml) → JSF backing bean (ShoppingBean) → EJB (CatalogMgr) → JPA (Inventory entity)
  - Navigation happens via #{shopping.performProductDetail} which reads itemID param
  - Product data wrapped in ProductBean for display

  Spring Boot (Current):
  - Mustache view → Spring MVC Controller → (currently: static data only)

  Your Options

  Option 1: Create a Full Product Page (Recommended for Learning)

  What it involves:
  1. Create ProductController with @GetMapping("/product") accepting itemID param
  2. Create service/repository layer to query INVENTORY table by inventoryId
  3. Create product.mustache template (port from product.xhtml)
  4. Handle image serving via /servlet/ImageServlet equivalent
  5. Add "Add to Cart" functionality (requires shopping cart state management)

  Pros: Complete feature parity, teaches full Spring Boot stack
  Cons: Most work (5 files + image servlet), requires session management for cart

  Option 2: Simple Read-Only Product Page (Pragmatic)

  What it involves:
  1. Create ProductController with GET mapping
  2. Create simple JDBC repository to fetch product by ID
  3. Create basic product.mustache showing product details (no cart functionality)
  4. Skip images initially (or serve from filesystem)

  Pros: Simpler, focuses on core MVC pattern, no state management
  Cons: Incomplete feature (no cart), doesn't match legacy functionality

  Option 3: REST API Only (Modern Architecture)

  What it involves:
  1. Create REST endpoint: @GetMapping("/api/product/{itemID}")
  2. Return JSON instead of HTML
  3. Optionally add JavaScript to render on promo page

  Pros: More modern, API-first approach, easier testing
  Cons: Changes UX paradigm, requires JavaScript work

  My Recommendation

  Start with Option 2, then evolve to Option 1:
  1. Create basic read-only product page (validates database connection, MVC pattern)
  2. Add image serving (teaches static resource handling)
  3. Add cart functionality (teaches session management)

  This incremental approach lets you validate each layer before adding complexity.

  Would you like me to proceed with Option 2 (simple read-only) or go straight to Option 1 (full cart functionality)?
</blockquote>

I don't care for option 3, the "modern" option of creating a REST endpoint, because it implies that we will also create a separate frontend, which is a lot of extra work.  Server-side HTML templates work fine, because [not all frontends need to be a full-blown SPA](https://www.thoughtworks.com/radar/techniques/spa-by-default "SPA by default | Technology Radar | Thoughtworks").

I am also not a fan of option 2, because it seems like a waste of time; I think CC should be able to go for the real implementation directly, but it should not rush ahead and implement the "add to cart" functionality yet.  Let's iterate the plan.

<blockquote>
  <b>I would like to go with Option 1, but let's skip the "Add to cart" functionality for now.  Also, start with a test
  </b>
  
⏺ Perfect choice, Captain Matt! Let me present a plan for implementing Option 1 (full product page) without the cart
  functionality, starting with a test following ATDD principles.

 Product Page Implementation Plan (Option 1, No Cart, Test-First)

 ATDD Approach - Start with Acceptance Test

 Phase 1: Acceptance Test (End-to-End)

 1. Create ProductControllerTest.java that:
   - Makes GET request to /product?itemID=T0003
   - Verifies HTTP 200 response
   - Verifies HTML contains: product name "Bonsai", price "$30.00", description, image tag
   - Uses actual database (or test database with known data)

 Phase 2: Implement to Make Test Pass

 2.1 Create Product Domain Model
 - spring-boot-pbw/src/main/java/it/xpug/pbw/domain/Product.java - POJO for product data

 2.2 Create Product Repository (JDBC)
 - spring-boot-pbw/src/main/java/it/xpug/pbw/repository/ProductRepository.java
 - Method: Product findByInventoryId(String inventoryId)
 - Query: SELECT * FROM INVENTORY WHERE INVENTORYID = ?
 - Handle null case (product not found)

 2.3 Create ProductController
 - spring-boot-pbw/src/main/java/it/xpug/pbw/controller/ProductController.java
 - @GetMapping("/product") accepting @RequestParam String itemID
 - Inject ProductRepository
 - Fetch product, add to Model
 - Return "product" template
 - Handle 404 if product not found

 2.4 Create Product Template
 - spring-boot-pbw/src/main/resources/templates/product.mustache
 - Port structure from pbw-web/src/main/webapp/product.xhtml
 - Show: product name, heading, description, price, package info, image
 - Add breadcrumb navigation (Home > Category)
 - Use layout.mustache pattern
 - Skip: quantity input, "Add to Cart" button (future feature)

 2.5 Handle Product Images
 - Create ImageController.java or static resource mapping
 - Serve images from /servlet/ImageServlet?action=getimage&inventoryID=... pattern
 - Either serve from database IMGBYTES column or fallback to filesystem

 Phase 3: Refactor & Unit Tests

 - Add unit tests for ProductRepository
 - Add unit tests for ProductController (mock repository)
 - Extract any business logic (e.g., price formatting)

 Expected Files to Create/Modify:

 - spring-boot-pbw/src/test/java/it/xpug/pbw/controller/ProductControllerTest.java (NEW)
 - spring-boot-pbw/src/main/java/it/xpug/pbw/domain/Product.java (NEW)
 - spring-boot-pbw/src/main/java/it/xpug/pbw/repository/ProductRepository.java (NEW)
 - spring-boot-pbw/src/main/java/it/xpug/pbw/controller/ProductController.java (NEW)
 - spring-boot-pbw/src/main/resources/templates/product.mustache (NEW)
 - spring-boot-pbw/src/main/java/it/xpug/pbw/controller/ImageController.java (NEW - for image serving)

 Ready to start with the acceptance test?
</blockquote>

Note that CC picks my preference for <abbr title="Acceptance-Test-Driven-Development">ATDD</abbr> from my global CLAUDE.md file, but gets it wrong.  It wants to start with the AT, but then write the unit tests as an afterthought. 

<blockquote>
  <b>OK with writing the AT first. But change the plan so that we write the unit test for the controller before we write the
    controller, and same with the repository.  Ok with serving the image from the IMGBYTES field of the INVENTORY table</b>

  ⏺ Perfect, Captain Matt! Let me revise the plan to follow proper TDD with unit tests before implementation.
  
 ATDD Approach - Test-First All The Way                                                                                   
                                                                                                                          
 Phase 1: Acceptance Test (End-to-End) - FAILING                                                                          
                                                                                                                          
 1. Create ProductControllerTest.java (integration test)                                                                  
   - GET /product?itemID=T0003 → expect 200                                                                               
   - Verify HTML contains: "Bonsai", "$30.00", description, image tag                                                     
   - This will FAIL - no controller exists yet                                                                            
                                                                                                                          
 Phase 2: Repository Layer (TDD)                                                                                          
                                                                                                                          
 2.1 Unit Test First                                                                                                      
 - Create ProductRepositoryTest.java                                                                                      
 - Test: findByInventoryId("T0003") returns Product with correct data                                                     
 - Test: findByInventoryId("INVALID") returns null                                                                        
 - Tests will FAIL - no repository exists                                                                                 
                                                                                                                          
 2.2 Implement Repository                                                                                                 
 - Create Product.java domain model (POJO)                                                                                
 - Create ProductRepository.java with JDBC                                                                                
 - Query: SELECT * FROM INVENTORY WHERE INVENTORYID = ?                                                                   
 - Run tests → GREEN                                                                                                      
                                                                                                                          
 Phase 3: Controller Layer (TDD)                                                                                          
                                                                                                                          
 3.1 Unit Test First                                                                                                      
 - Create ProductControllerUnitTest.java (mock repository)                                                                
 - Test: GET with valid itemID → model has product, returns "product" view                                                
 - Test: GET with invalid itemID → returns 404 or error page                                                              
 - Tests will FAIL - no controller exists                                                                                 
                                                                                                                          
 3.2 Implement Controller                                                                                                 
 - Create ProductController.java                                                                                          
 - @GetMapping("/product") with @RequestParam String itemID                                                               
 - Inject ProductRepository, fetch product, add to Model                                                                  
 - Run tests → GREEN                                                                                                      
                                                                                                                          
 Phase 4: Template & Images                                                                                               
                                                                                                                          
 4.1 Create Product Template                                                                                              
 - product.mustache - port from product.xhtml                                                                             
 - Show: name, heading, description, price, pkginfo, image                                                                
 - Breadcrumb navigation                                                                                                  
 - NO cart functionality                                                                                                  
                                                                                                                          
 4.2 Image Serving (TDD)                                                                                                  
 - Unit test: ImageControllerTest.java                                                                                    
 - Test: GET /servlet/ImageServlet?action=getimage&inventoryID=T0003 returns image bytes                                  
 - Implement ImageController.java to serve from INVENTORY.IMGBYTES                                                        
 - Run tests → GREEN                                                                                                      
                                                                                                                          
 Phase 5: Run Acceptance Test                                                                                             
                                                                                                                          
 - Run ProductControllerTest (integration test) → should be GREEN                                                         
 - Manual test: http://localhost:8080/product?itemID=T0003                                                                
                                                                                                                          
 Files to Create (in order):                                                                                              
                                                                                                                          
 1. ProductControllerTest.java (integration test - FAILING)                                                               
 2. ProductRepositoryTest.java (unit test - FAILING)                                                                      
 3. Product.java (domain model)                                                                                           
 4. ProductRepository.java (implementation)                                                                               
 5. ProductControllerUnitTest.java (unit test - FAILING)                                                                  
 6. ProductController.java (implementation)                                                                               
 7. product.mustache (template)                                                                                           
 8. ImageControllerTest.java (unit test - FAILING)                                                                        
 9. ImageController.java (implementation)                                                                                 
                                                                                                                          
 Ready to start with the acceptance test?                                                                                   
</blockquote>

Now this begins to look good!  I will accept the plan and get CC to start with the implementation.  Let's see what code it comes up with.

## Implementation

The plan is not trivial; luckily CC has a `TodoWrite` tool at its disposal that it can use to keep track of what it's doing and not get lost.  Here is how its todo list looks at first

<figure style="margin: 0 auto; display: block; width: 80%">
  <img src="initial-todo-list.jpg" alt="The Claude Code todo list">
</figure>

Gee, I *love it* that it plans to test the application "manually" in the browser.

**The "let the AI do the testing" heuristic**: When the AI claims it's done with a task, let's ask the AI itself to verify it. It should use some sort of tool or MCP to access the UI of what it built and test it "manually".  In this case, I didn't have to ask.


I observe what CC is doing; it is indeed creating the AT and unit tests before the code; however, it is happy to see them fail because of compilation errors.  Proper TDD would be to write a minimal implementation for the code under test so that it compiles, and fails for the right reason, namely that the logic is not yet implemented.  I could stop it and insist for it to follow the proper process, but I will let it go for now.  The risk is that the tests, once they compile, never fail because of some logic error in the tests.  I might check this later by injecting a fault in the code to get to see the tests fail.

True to its word, after all the steps are completed (it took less time that it took me to write this section up to here), it checked that the page works with the Puppetteer MCP.  It first opened the Bonsai tree page, took a screenshot and examined it.  It looks pretty much like the original:

<figure style="margin: 0 auto; display: block; width: 80%">
  <img src="bonsai-page-ported.jpg" alt="The ported Bonsai tree page" style='border: 1px solid black'>
</figure>

The image is broken, but that is expected since the IMGBYTES column is empty. I'll get to that later.
Then it opened the page for a different product, took another screenshot and examined it.  

<figure style="margin: 0 auto; display: block; width: 80%">
  <img src="strawberry-page-ported.jpg" alt="The product page for another product" style='border: 1px solid black'>
</figure>

Pretty good testing; however, it did not check what happens when the ID parameter is wrong.  It should have, since it wrote tests that prove that this functionality works correctly.

<blockquote>
  ⏺ Success! 🎉

Captain Matt, I've successfully ported the product page to Spring Boot using Test-Driven Development (TDD) and ATDD
principles! Here's what we accomplished:

What We Built

Product Detail Page at /product?itemID=T0003 with:
- ✅ Product name, heading, description
- ✅ Price formatting ($30.00)
- ✅ Package info
- ✅ Product images served from database
- ✅ Breadcrumb navigation (Home > Category)
- ✅ Full page layout with header, navigation, footer

Files Created (9 files total)

Tests (Test-First!):
1. ProductControllerTest.java - Integration/acceptance test
2. ProductRepositoryTest.java - Unit test for repository
3. ProductControllerUnitTest.java - Unit test for controller
4. ImageControllerTest.java - Unit test for image serving

Implementation:

5. Product.java - Domain model (POJO)
6. ProductRepository.java - JDBC repository for product data
7. ProductController.java - MVC controller
8. ImageController.java - Image serving from IMGBYTES
9. ImageRepository.java - Repository for image data
10. product.mustache - HTML template

Test Results

- ✅ All 15 tests passing (4 acceptance + 4 repository + 3 controller + 4 image)
- ✅ Manual browser testing successful for Bonsai and Strawberries

What We Skipped (as requested)

- ❌ "Add to Cart" functionality (can be added later)
- ✅ But kept the quantity field visible in the UI
</blockquote>

I often have the feeling that Claude is mocking me. See how in the results above it says "Test-First!", as if to say: "are you happy now, you human with this silly insistence on writing the tests first?" 😄

I now check the state of the context window with `/context`, and it's almost full at 82%; let's hope we don't have to iterate much on these results.


## Verifying

Now it's time to take a look at the code it wrote.



*Want to leave a comment? Please do so on Linkedin!*
