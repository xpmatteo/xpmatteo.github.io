<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: Design by Contract vs. Test-Driven Development	</title>
	<atom:link href="http://matteo.vaccari.name/blog/archives/602/feed" rel="self" type="application/rss+xml" />
	<link>http://matteo.vaccari.name/blog/archives/602</link>
	<description>Extreme enthusiasm</description>
	<lastBuildDate>
	Mon, 25 Feb 2019 15:18:16 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.1.1</generator>
			<item>
				<title>
				By: matteo				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-95006</link>
		<dc:creator><![CDATA[matteo]]></dc:creator>
		<pubDate>Tue, 03 Apr 2012 16:12:23 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-95006</guid>
					<description><![CDATA[Balthazar,

&lt;blockquote&gt;
Yes, I know. I was focusing on the precondition part because that’s where your more obvious lack of understanding for what DbC meant where to be found.

I could pass your own test, like this:
function squeeze(x)
if x equals “” then return “”
if x equals “aaabbccccaa” then return “abca”
end
&lt;/blockquote&gt;

The precondition is obvious and uninteresting for the point I want to make in this article.

Consider that the simple TDD test proves that the implementation works correctly in &lt;em&gt;at least one case&lt;/em&gt;.  This is a crucial point; your weak postcondition does not even do that.  It does not matter that I can easily &quot;fool&quot; the TDD tests by answering exactly the cases that are being tested.  When I do TDD, I write the tests to support my coding.  TDD tests are whitebox tests, not blackbox tests.]]></description>
		<content:encoded><![CDATA[<p>Balthazar,</p>
<blockquote><p>
Yes, I know. I was focusing on the precondition part because that’s where your more obvious lack of understanding for what DbC meant where to be found.</p>
<p>I could pass your own test, like this:<br />
function squeeze(x)<br />
if x equals “” then return “”<br />
if x equals “aaabbccccaa” then return “abca”<br />
end
</p></blockquote>
<p>The precondition is obvious and uninteresting for the point I want to make in this article.</p>
<p>Consider that the simple TDD test proves that the implementation works correctly in <em>at least one case</em>.  This is a crucial point; your weak postcondition does not even do that.  It does not matter that I can easily &#8220;fool&#8221; the TDD tests by answering exactly the cases that are being tested.  When I do TDD, I write the tests to support my coding.  TDD tests are whitebox tests, not blackbox tests.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Balthazar				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-95005</link>
		<dc:creator><![CDATA[Balthazar]]></dc:creator>
		<pubDate>Tue, 03 Apr 2012 13:39:54 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-95005</guid>
					<description><![CDATA[Update: I have been reading a bit more about TDD, and thought about the big obstacles to employing DbC to a project. The biggest obstacle to DbC is that there is no native language support for the c family of languages. This makes the benefits diminish. In addition, there are the many difficulties associated with writing posconditions. Say you have an hash table, writing a postcondition for the set function would be easy, but writing a postcondition for the get function much harder. But then again, in many cases DbC could be great. Say you had a layout system which could enforce right margin alignment to text, like what you have in the comments section on this page. In that case, writing the postcondition as a function that checks that each word is correctly aligned wouldn&#039;t be hard. A class invariant could check whether the distance between each word on a line is always equal, which would work equally well for right alignment and block alignment.

Anyway, because of the drawbacks to DbC, and after reading many posters being happy with TDD, I have decided I&#039;ll try to adopt TDD instead as a start. The two systems are clearly not mutually exclusive, but TDD is available right out-of-the-box in my development API&#039;s/IDE. Since my application is largely GUI-centric, there are parts of it that can&#039;t be developed that way, but looking at my codebase, that is currently just a rather thin view layer that would need to be tested by a human. It is already fairly modular and decoupled as TDD-ers recommend. Also, my application requires much lock free concurrency, and needs to host third-party plug-ins, so I believe there&#039;s no way I can get around live testing. DbC would be a great add-on for this, in addition to TDD, but it&#039;s just not available. (at least *real* DbC).]]></description>
		<content:encoded><![CDATA[<p>Update: I have been reading a bit more about TDD, and thought about the big obstacles to employing DbC to a project. The biggest obstacle to DbC is that there is no native language support for the c family of languages. This makes the benefits diminish. In addition, there are the many difficulties associated with writing posconditions. Say you have an hash table, writing a postcondition for the set function would be easy, but writing a postcondition for the get function much harder. But then again, in many cases DbC could be great. Say you had a layout system which could enforce right margin alignment to text, like what you have in the comments section on this page. In that case, writing the postcondition as a function that checks that each word is correctly aligned wouldn&#8217;t be hard. A class invariant could check whether the distance between each word on a line is always equal, which would work equally well for right alignment and block alignment.</p>
<p>Anyway, because of the drawbacks to DbC, and after reading many posters being happy with TDD, I have decided I&#8217;ll try to adopt TDD instead as a start. The two systems are clearly not mutually exclusive, but TDD is available right out-of-the-box in my development API&#8217;s/IDE. Since my application is largely GUI-centric, there are parts of it that can&#8217;t be developed that way, but looking at my codebase, that is currently just a rather thin view layer that would need to be tested by a human. It is already fairly modular and decoupled as TDD-ers recommend. Also, my application requires much lock free concurrency, and needs to host third-party plug-ins, so I believe there&#8217;s no way I can get around live testing. DbC would be a great add-on for this, in addition to TDD, but it&#8217;s just not available. (at least *real* DbC).</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Balthazar				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-95003</link>
		<dc:creator><![CDATA[Balthazar]]></dc:creator>
		<pubDate>Mon, 02 Apr 2012 09:10:34 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-95003</guid>
					<description><![CDATA[Yes, I know. I was focusing on the precondition part because that&#039;s where your more obvious lack of understanding for what DbC meant where to be found. 

I could pass your own test, like this:
function squeeze(x)
    if x equals &quot;&quot; then return &quot;&quot;
    if x equals &quot;aaabbccccaa&quot; then return &quot;abca&quot; 
end

Also, it seemed you didn&#039;t understand that the check could be implemnted as functions or class methods. Regarding your two additional checks, I might write each of them too as functions. Then the function name, plus the description, which is part of the contract, would be very self explanatory in my view. It seems to me as you are confusing Can&#039;t Solve All The Problems In The World for unusable. DbC can&#039;t solve all the problems in the world, and you may need to write some additional specs (like you would in your TDD examples) but, not having tried it out, I believe it can be a good help in structuring your code.

Of course, I would need to test my code with several examples. DbC is not meant to be a substitute for testing, rather and aid to it. When you write &quot;And your assertion does not drive you toward a solution. As Carlo says above (please read his comment carefully, as he has some useful and non-obvious things to say), if it does not help you find the shape of your code, then it’s not a design method&quot;. I couldn&#039;t disagree more!! It most certainly does help my designing of the program. By clarifying my contracts, I am lying out the structure of the program in terms of obligations and benefits between each different part of the program, so, it could be a huge help in defining the overall structure of the program. How to the parts play TOGETHER, that&#039;s what DbC seems to focus on, not how should each feature be IMPLEMENTED. You seem to be focusing on implementation, not on interplay/communication between different parts of the software. The principle here is that we see each class, method, function whatever as either a supplier or a client, and in most cases I guess both, and the contracts help define the relationships and rules between them. Implementation solutions and software design are not the same thing. And manually parsing a long list of test cases like the one you suggest in your post doesn&#039;t seem like a good help in figuring out how the main structure of the software works, or how to use or extend a class. On the other hand, preconditions seem like a stronger part of the DbC design paradigm than postconditions. That&#039;s meaybe the reason why I focus on the pres and you focus on the posts.

I have tried, instead of reading Carlo&#039;s post (which I will read later), to get a bit more educated on TDD. So far, it seems extremely tedious and unusable for my case. In my case I am working on a piece of software that requires a lot of concurrency and lock free data structures, because it is a realtime app. It also requires a VERY complex GUI, which is what I am currently working on. I have been thinking about how I should write the test cases for the GUI, and have problems figuring out how. I would have to write some sort of simulator, that simulates each mouseclick, mousedragged or mousemoved action, plus combinations with modifier keys, which would be perhaps thousands of events during a user session, and don&#039;t forget that there are million trillion gazzillion possible combinations of those... I thought of writing an event recorder, which would be a very different approach from the TDD process anyway, but that wouldn&#039;t help me much. Soon as I change some sizes and values in my code, the &quot;test cases&quot; would be invalidated, because graphical elements (in this case cells in a tree-like matrix) would get laid out differently on the screen. So I believe I would have to write some sort of test cases manually (HUGE JOB) that were tightly integrated with the implementation of my graphical layout system, and then it turns out writing and maintaining the test cases could get much harder and time consuming than writing the actual code. Sure I could end up with something useful, but if I have then overlooked some user interaction sequence, and invoke that sequence during live testing, the already written test cases would not help me catching the bug.

That&#039;s where I thought DbC might come handy. DbC focuses not only on how the suppliers behave under a constrained set of data, but on how the pieces play TOGETHER. So, if I invoke a new bug in my program during live testing, the error will be caught at a much earlier time. Of course this could be easily combined with an event recorder which helps me reproduce the error. This focus on how the parts play together is what we all rely on, actually, when we start using a new library. Your test cases can&#039;t help ensure that you use your libraries right, but assertions in (most of) these libraries help ensure this to some degree, at least. And this functionality is in fact a very basic application of DbC design. But, if you really are able to predict all possible user interactions, and really stick to the TDD mantras in a die-hard way, I agree that TDD seem to be a far more bulletproof way of ensuring bug free code than DbC.]]></description>
		<content:encoded><![CDATA[<p>Yes, I know. I was focusing on the precondition part because that&#8217;s where your more obvious lack of understanding for what DbC meant where to be found. </p>
<p>I could pass your own test, like this:<br />
function squeeze(x)<br />
    if x equals &#8220;&#8221; then return &#8220;&#8221;<br />
    if x equals &#8220;aaabbccccaa&#8221; then return &#8220;abca&#8221;<br />
end</p>
<p>Also, it seemed you didn&#8217;t understand that the check could be implemnted as functions or class methods. Regarding your two additional checks, I might write each of them too as functions. Then the function name, plus the description, which is part of the contract, would be very self explanatory in my view. It seems to me as you are confusing Can&#8217;t Solve All The Problems In The World for unusable. DbC can&#8217;t solve all the problems in the world, and you may need to write some additional specs (like you would in your TDD examples) but, not having tried it out, I believe it can be a good help in structuring your code.</p>
<p>Of course, I would need to test my code with several examples. DbC is not meant to be a substitute for testing, rather and aid to it. When you write &#8220;And your assertion does not drive you toward a solution. As Carlo says above (please read his comment carefully, as he has some useful and non-obvious things to say), if it does not help you find the shape of your code, then it’s not a design method&#8221;. I couldn&#8217;t disagree more!! It most certainly does help my designing of the program. By clarifying my contracts, I am lying out the structure of the program in terms of obligations and benefits between each different part of the program, so, it could be a huge help in defining the overall structure of the program. How to the parts play TOGETHER, that&#8217;s what DbC seems to focus on, not how should each feature be IMPLEMENTED. You seem to be focusing on implementation, not on interplay/communication between different parts of the software. The principle here is that we see each class, method, function whatever as either a supplier or a client, and in most cases I guess both, and the contracts help define the relationships and rules between them. Implementation solutions and software design are not the same thing. And manually parsing a long list of test cases like the one you suggest in your post doesn&#8217;t seem like a good help in figuring out how the main structure of the software works, or how to use or extend a class. On the other hand, preconditions seem like a stronger part of the DbC design paradigm than postconditions. That&#8217;s meaybe the reason why I focus on the pres and you focus on the posts.</p>
<p>I have tried, instead of reading Carlo&#8217;s post (which I will read later), to get a bit more educated on TDD. So far, it seems extremely tedious and unusable for my case. In my case I am working on a piece of software that requires a lot of concurrency and lock free data structures, because it is a realtime app. It also requires a VERY complex GUI, which is what I am currently working on. I have been thinking about how I should write the test cases for the GUI, and have problems figuring out how. I would have to write some sort of simulator, that simulates each mouseclick, mousedragged or mousemoved action, plus combinations with modifier keys, which would be perhaps thousands of events during a user session, and don&#8217;t forget that there are million trillion gazzillion possible combinations of those&#8230; I thought of writing an event recorder, which would be a very different approach from the TDD process anyway, but that wouldn&#8217;t help me much. Soon as I change some sizes and values in my code, the &#8220;test cases&#8221; would be invalidated, because graphical elements (in this case cells in a tree-like matrix) would get laid out differently on the screen. So I believe I would have to write some sort of test cases manually (HUGE JOB) that were tightly integrated with the implementation of my graphical layout system, and then it turns out writing and maintaining the test cases could get much harder and time consuming than writing the actual code. Sure I could end up with something useful, but if I have then overlooked some user interaction sequence, and invoke that sequence during live testing, the already written test cases would not help me catching the bug.</p>
<p>That&#8217;s where I thought DbC might come handy. DbC focuses not only on how the suppliers behave under a constrained set of data, but on how the pieces play TOGETHER. So, if I invoke a new bug in my program during live testing, the error will be caught at a much earlier time. Of course this could be easily combined with an event recorder which helps me reproduce the error. This focus on how the parts play together is what we all rely on, actually, when we start using a new library. Your test cases can&#8217;t help ensure that you use your libraries right, but assertions in (most of) these libraries help ensure this to some degree, at least. And this functionality is in fact a very basic application of DbC design. But, if you really are able to predict all possible user interactions, and really stick to the TDD mantras in a die-hard way, I agree that TDD seem to be a far more bulletproof way of ensuring bug free code than DbC.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: matteo				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-95002</link>
		<dc:creator><![CDATA[matteo]]></dc:creator>
		<pubDate>Mon, 02 Apr 2012 05:02:46 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-95002</guid>
					<description><![CDATA[Hello Balthazar,

indeed your post-condition is very easy to write, but it&#039;s not a very strong postcondition.  I could implement your specification with

function squeeze(x)
  return &quot;abc&quot;;
end

and still pass your assertions.  You should add

ensure
all input characters can be found in output: ...
all output characters are in the same order as in the input: ....

And I would find it difficult to write those assertions in a way that is super-clear what they mean.

I mean, your assertion is certainly a useful check.  It&#039;s not a sufficient check; you would need to test your code on several examples.  And your assertion does not drive you toward a solution.  As Carlo says above (please read his comment carefully, as he has some useful and non-obvious things to say), if it does not help you find the shape of your code, then it&#039;s not a design method.  

If all you do is check simple properties of your output then what you have is a tool for protecting you from errors, not a design tool.  Valuable, yes, but I would still want something else for a design tool.

Matteo]]></description>
		<content:encoded><![CDATA[<p>Hello Balthazar,</p>
<p>indeed your post-condition is very easy to write, but it&#8217;s not a very strong postcondition.  I could implement your specification with</p>
<p>function squeeze(x)<br />
  return &#8220;abc&#8221;;<br />
end</p>
<p>and still pass your assertions.  You should add</p>
<p>ensure<br />
all input characters can be found in output: &#8230;<br />
all output characters are in the same order as in the input: &#8230;.</p>
<p>And I would find it difficult to write those assertions in a way that is super-clear what they mean.</p>
<p>I mean, your assertion is certainly a useful check.  It&#8217;s not a sufficient check; you would need to test your code on several examples.  And your assertion does not drive you toward a solution.  As Carlo says above (please read his comment carefully, as he has some useful and non-obvious things to say), if it does not help you find the shape of your code, then it&#8217;s not a design method.  </p>
<p>If all you do is check simple properties of your output then what you have is a tool for protecting you from errors, not a design tool.  Valuable, yes, but I would still want something else for a design tool.</p>
<p>Matteo</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Balthazar				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-95001</link>
		<dc:creator><![CDATA[Balthazar]]></dc:creator>
		<pubDate>Sun, 01 Apr 2012 23:02:56 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-95001</guid>
					<description><![CDATA[Oh, and one more thing: One possible reason why DbC is not widespread, is that there aren&#039;t any good DbC-solutions for existing languages out there. DbC is part of the design process, and should preferably be an integrated part of the language. Those languages that do support it natively, are at least not very widespread. And one precondition check I forgot to put into my example which is very important: Check that your string really is a valid string. Depending on the language used, a memory-related or some other type of bug might cause the string to contain invalid characters. If the function is only intended for valid strings, it should be specified in the contract. Again, this memory-related bug might be caught by the type of tests you suggest, but it will happen at a much later time in the execution, and will be much harder to track down. Particularly if you are using a library or some supplier code that you didn&#039;t write yourself.]]></description>
		<content:encoded><![CDATA[<p>Oh, and one more thing: One possible reason why DbC is not widespread, is that there aren&#8217;t any good DbC-solutions for existing languages out there. DbC is part of the design process, and should preferably be an integrated part of the language. Those languages that do support it natively, are at least not very widespread. And one precondition check I forgot to put into my example which is very important: Check that your string really is a valid string. Depending on the language used, a memory-related or some other type of bug might cause the string to contain invalid characters. If the function is only intended for valid strings, it should be specified in the contract. Again, this memory-related bug might be caught by the type of tests you suggest, but it will happen at a much later time in the execution, and will be much harder to track down. Particularly if you are using a library or some supplier code that you didn&#8217;t write yourself.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Balthazar				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-95000</link>
		<dc:creator><![CDATA[Balthazar]]></dc:creator>
		<pubDate>Sun, 01 Apr 2012 22:34:22 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-95000</guid>
					<description><![CDATA[I have been contemplating about getting into DbC, and searching for discussions about whether it&#039;s really good in practice. That&#039;s how I stumbled across this page. One reason for this is that for my latest project I started sprinkling my code with asertions all over, and it surprised me how I immediately found bugs that would have taken so much longer to track down earlier. Therefore, I started thinking about whether I should take it a step further, to write formal specifications that would act both as documentation for my suppliers, and at the same time act as early bug catchers during development.

I must say it seems people don&#039;t really understand what DbC is, and your post is a great example. It&#039;s super easy to write the contract you want. Basically, you write a function that checks whether all characters in the output string are unique. Then, you use the function as your post-condition, something like this:

require
    input string is not null: inputString /= NULL; // Important check!!!

ensure
    all characters are unique: allCharactersUnique( returnValue );

invariant
    // various sanity checks that you never thought could fail here.


This is written in a sort of imagined DbC language that is a bit like Eiffel and a bit like C... :) The invariant is defined at class level, the pre and post conditions at method level. The precondition here is very important. It is not true, as you suggest, that all input is valid. The point is exactly that both the client and supplier behaviour is checked, as a result of your formal contracts. Your intent is clear, correctness is better ensured (but not guaranteed), and you both get to check supplier AND client behaviour. I don&#039;t know much about test-driven development (maybe I should check it out), but in your examples given, (A) you only get to check for a specific set of inputs, (B) you only check supplier behaviour, not client behaviour. 

The main hazard during developing may not be that your suppliers don&#039;t work correctly, because when you write them your first time, you will probably put much thought into it. But later you may forget the details about what the class requires, your clients may use them incorrectly, or some other bug somewhere causes a function to be called with the wrong arguments, or you may make a change somewhere that you didn&#039;t think could affect other parts of the program. This will produce incorrect results also for the kind of tests you suggest as &quot;TDD-style tests&quot;, but you will catch them later, and the sooner they are caught the easier they are to find. This saves much time. All these points are of course even more true in a big project with many developers. The best thing would be if, as soon as something was in an unexpected state, the debugger would stop at that line where the error happened. This may not be so easy to achieve with any development style.

Apart from that, I believe no matter what design principle you choose, it must be tested with a broad range of data. Each supplier must, of course be thoroughly tested on its own. If that&#039;s what TDD means, then I suppose I agree with a previous poster, both techniques should be used together.]]></description>
		<content:encoded><![CDATA[<p>I have been contemplating about getting into DbC, and searching for discussions about whether it&#8217;s really good in practice. That&#8217;s how I stumbled across this page. One reason for this is that for my latest project I started sprinkling my code with asertions all over, and it surprised me how I immediately found bugs that would have taken so much longer to track down earlier. Therefore, I started thinking about whether I should take it a step further, to write formal specifications that would act both as documentation for my suppliers, and at the same time act as early bug catchers during development.</p>
<p>I must say it seems people don&#8217;t really understand what DbC is, and your post is a great example. It&#8217;s super easy to write the contract you want. Basically, you write a function that checks whether all characters in the output string are unique. Then, you use the function as your post-condition, something like this:</p>
<p>require<br />
    input string is not null: inputString /= NULL; // Important check!!!</p>
<p>ensure<br />
    all characters are unique: allCharactersUnique( returnValue );</p>
<p>invariant<br />
    // various sanity checks that you never thought could fail here.</p>
<p>This is written in a sort of imagined DbC language that is a bit like Eiffel and a bit like C&#8230; :) The invariant is defined at class level, the pre and post conditions at method level. The precondition here is very important. It is not true, as you suggest, that all input is valid. The point is exactly that both the client and supplier behaviour is checked, as a result of your formal contracts. Your intent is clear, correctness is better ensured (but not guaranteed), and you both get to check supplier AND client behaviour. I don&#8217;t know much about test-driven development (maybe I should check it out), but in your examples given, (A) you only get to check for a specific set of inputs, (B) you only check supplier behaviour, not client behaviour. </p>
<p>The main hazard during developing may not be that your suppliers don&#8217;t work correctly, because when you write them your first time, you will probably put much thought into it. But later you may forget the details about what the class requires, your clients may use them incorrectly, or some other bug somewhere causes a function to be called with the wrong arguments, or you may make a change somewhere that you didn&#8217;t think could affect other parts of the program. This will produce incorrect results also for the kind of tests you suggest as &#8220;TDD-style tests&#8221;, but you will catch them later, and the sooner they are caught the easier they are to find. This saves much time. All these points are of course even more true in a big project with many developers. The best thing would be if, as soon as something was in an unexpected state, the debugger would stop at that line where the error happened. This may not be so easy to achieve with any development style.</p>
<p>Apart from that, I believe no matter what design principle you choose, it must be tested with a broad range of data. Each supplier must, of course be thoroughly tested on its own. If that&#8217;s what TDD means, then I suppose I agree with a previous poster, both techniques should be used together.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: matteo				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-94236</link>
		<dc:creator><![CDATA[matteo]]></dc:creator>
		<pubDate>Mon, 04 Jul 2011 11:15:09 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-94236</guid>
					<description><![CDATA[Hi Mario,

I have nothing in general against the use of assertions; I just find them less effective than TDD.  They are a different technique and I find that while assertions are very useful when coding in a non-TDD way, I don&#039;t miss them when I do TDD.

That&#039;s because when you do TDD you get to write code that&#039;s much shorter; you have methods that rarely are longer than 10 lines.  You get to break your problem in much smaller pieces that you test and think about more thouroughly.

Even doing DBC would get you to much smaller pieces, as the comment by Carlo Pescio suggests (though I don&#039;t have real experience in DBC).

I&#039;m all in favor of doing plenty of testing; I think your approach of comparing two algorithms is a very good idea.  But we are comparing different things: *testing* techniques versus *design* techniques.

DBC and TDD are *design* techniques, not test techniques. It happens that they produce test code as a side-product, which is good; but the goal is to get to a good design, not (primarily) to ensure that the code is correct.

(About your remark on the recursive implementation of squeeze: sure, you could rewrite it as a tail-recursive function that does not stack-overflow, but then you&#039;d make it less readable.  The goal in DBC is to have obviously correct specs.  The version I give is obviously correct from a mathematical point of view.)]]></description>
		<content:encoded><![CDATA[<p>Hi Mario,</p>
<p>I have nothing in general against the use of assertions; I just find them less effective than TDD.  They are a different technique and I find that while assertions are very useful when coding in a non-TDD way, I don&#8217;t miss them when I do TDD.</p>
<p>That&#8217;s because when you do TDD you get to write code that&#8217;s much shorter; you have methods that rarely are longer than 10 lines.  You get to break your problem in much smaller pieces that you test and think about more thouroughly.</p>
<p>Even doing DBC would get you to much smaller pieces, as the comment by Carlo Pescio suggests (though I don&#8217;t have real experience in DBC).</p>
<p>I&#8217;m all in favor of doing plenty of testing; I think your approach of comparing two algorithms is a very good idea.  But we are comparing different things: *testing* techniques versus *design* techniques.</p>
<p>DBC and TDD are *design* techniques, not test techniques. It happens that they produce test code as a side-product, which is good; but the goal is to get to a good design, not (primarily) to ensure that the code is correct.</p>
<p>(About your remark on the recursive implementation of squeeze: sure, you could rewrite it as a tail-recursive function that does not stack-overflow, but then you&#8217;d make it less readable.  The goal in DBC is to have obviously correct specs.  The version I give is obviously correct from a mathematical point of view.)</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Mario				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-94235</link>
		<dc:creator><![CDATA[Mario]]></dc:creator>
		<pubDate>Mon, 04 Jul 2011 10:20:39 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-94235</guid>
					<description><![CDATA[I totally disagree with your statement that assertions that are easy to write are not worth much. Actually, that&#039;s the kind of statement that I would expect from someone who has never really tried to use assertions in practice. But let me try to explain in more detail why I think that, and give you some examples.

First of all, some quick answers: I write my assertion while I write the code, sometimes afterwards, never before. (and I do the same with tests: I find that neither gives any useful non-trivial insight in the design phase. Though I guess you would disagree here). Most of the time, if some assertion/contract is too complex, I usually don&#039;t bother to code it (but see what I say at the end of the post). And in the case of a function like &quot;squeeze&quot; for example, I can&#039;t see any contract worth enforcing, so I would just rely on a few tests there.

Also, many assertions that I write are not pre/postconditions, but are just embedded in the body of functions. Whenever the code I&#039;m writing depends on some non-trivial condition, but I&#039;m not entirely sure the surrounding code maintains it, I usually prefer to enforce it with an assertion.

Before writing this post I looked at some code I wrote recently that I believe can make a pretty good example, since it&#039;s the kind of relatively complex algorithmical code that&#039;s next to impossible for me to get right without some very serious testing. It&#039;s the solutions to some (about 10 of them) of the puzzles posted by Facebook on their web site (see http://www.facebook.com/careers/puzzles.php). I found that my code had about one assertion every 20 &quot;real&quot; lines of code. So it&#039;s hardly a comprehensive coverage. Many functions/methods didn&#039;t have any. All of them (except one) where just simple one-liners that took me at most ten seconds to write. Did they make testing redundant, or did they uncover all the bugs in the code? Surely not. Not even close to that, actually. But in practice they turned out to be very useful, allowing me to catch many bugs early and with very little effort.

In this particular case, would I have caught those bugs anyway eventually? I guess so, given how thoroughly I tested the code (but again, read the end of the post). Although I&#039;m sure it would have taken both more time and more effort. But in practice not all code allows for such a complete testing in any reasonable amount of time (just to give you an example, think of a method that updates a large and complex data structure. How do you test that?). And in my experience, assertions/contracts do help find bugs that would otherwise escape testing.

To answer you last question, I find them useful in many ways. As you mentioned, the most important part is the runtime checks. But there are also other factors:

- Most of the time they pinpoint the offending lines of code. That&#039;s something I do not get with testing alone. If a function fails a test, more often that not that doesn&#039;t clearly show me where the error originated.

- When used as preconditions, they are a useful form of documentation. They remind me what conditions the parameters must satisfy.

- They sometimes also help me to understand better how my code works, by writing down some conditions that I expect to be true during program execution.

I also would like to spend a few words to defend another technique that I believe you dismissed too quickly in your post. You said that the second version of the postcondition is actually executable code, so that it could be used as an implementation. But quite apart from the fact that even in your simple case that&#039;s not true (I believe that implementation would cause a stack overflow if the input string were long enough), that&#039;s again missing the point. Let me use again the Facebook puzzles example. To test my code, in all cases except one, I didn&#039;t write any standard tests. I just wrote two versions of it: I first coded a very simple brute-force solution, that wouldn&#039;t have been usable in practice because too slow. Then I wrote the optimized algorithm, that was sometimes nearly an order of magnitude more complex. And then I randomly generated thousands of test cases, run them through both algorithms and compared the results. In the end, every piece of code I submitted passed all the Facebook tests the first time, so the technique was certainly effective in removing bugs (Facebook sources say that on average only about 10% of the submissions they receive manage to pass all their tests). And all with a reasonably small effort. Now, you can make up your own mind about whether this tecnique should be classified as a form of testing (comparison testing, as I believe it&#039;s usually called in the literature) or as a thorough use of postconditions. But I&#039;m pretty sure that if I had tried to debug my code using only &quot;example testing&quot; not only I would have had to do much more work (and very boring work at that), but I wouldn&#039;t have got anywhere close to the same level of testing.

In general, while I agree that &quot;example testing&quot; is in many case necessary, and that you can get reasonably bug-free code with it alone if you work hard enough at it, I also believe you&#039;ll get better result with significantly less effort if you combine it with assertions/contracts and comparison testing (and maybe other techniques).]]></description>
		<content:encoded><![CDATA[<p>I totally disagree with your statement that assertions that are easy to write are not worth much. Actually, that&#8217;s the kind of statement that I would expect from someone who has never really tried to use assertions in practice. But let me try to explain in more detail why I think that, and give you some examples.</p>
<p>First of all, some quick answers: I write my assertion while I write the code, sometimes afterwards, never before. (and I do the same with tests: I find that neither gives any useful non-trivial insight in the design phase. Though I guess you would disagree here). Most of the time, if some assertion/contract is too complex, I usually don&#8217;t bother to code it (but see what I say at the end of the post). And in the case of a function like &#8220;squeeze&#8221; for example, I can&#8217;t see any contract worth enforcing, so I would just rely on a few tests there.</p>
<p>Also, many assertions that I write are not pre/postconditions, but are just embedded in the body of functions. Whenever the code I&#8217;m writing depends on some non-trivial condition, but I&#8217;m not entirely sure the surrounding code maintains it, I usually prefer to enforce it with an assertion.</p>
<p>Before writing this post I looked at some code I wrote recently that I believe can make a pretty good example, since it&#8217;s the kind of relatively complex algorithmical code that&#8217;s next to impossible for me to get right without some very serious testing. It&#8217;s the solutions to some (about 10 of them) of the puzzles posted by Facebook on their web site (see <a href="http://www.facebook.com/careers/puzzles.php" rel="nofollow">http://www.facebook.com/careers/puzzles.php</a>). I found that my code had about one assertion every 20 &#8220;real&#8221; lines of code. So it&#8217;s hardly a comprehensive coverage. Many functions/methods didn&#8217;t have any. All of them (except one) where just simple one-liners that took me at most ten seconds to write. Did they make testing redundant, or did they uncover all the bugs in the code? Surely not. Not even close to that, actually. But in practice they turned out to be very useful, allowing me to catch many bugs early and with very little effort.</p>
<p>In this particular case, would I have caught those bugs anyway eventually? I guess so, given how thoroughly I tested the code (but again, read the end of the post). Although I&#8217;m sure it would have taken both more time and more effort. But in practice not all code allows for such a complete testing in any reasonable amount of time (just to give you an example, think of a method that updates a large and complex data structure. How do you test that?). And in my experience, assertions/contracts do help find bugs that would otherwise escape testing.</p>
<p>To answer you last question, I find them useful in many ways. As you mentioned, the most important part is the runtime checks. But there are also other factors:</p>
<p>&#8211; Most of the time they pinpoint the offending lines of code. That&#8217;s something I do not get with testing alone. If a function fails a test, more often that not that doesn&#8217;t clearly show me where the error originated.</p>
<p>&#8211; When used as preconditions, they are a useful form of documentation. They remind me what conditions the parameters must satisfy.</p>
<p>&#8211; They sometimes also help me to understand better how my code works, by writing down some conditions that I expect to be true during program execution.</p>
<p>I also would like to spend a few words to defend another technique that I believe you dismissed too quickly in your post. You said that the second version of the postcondition is actually executable code, so that it could be used as an implementation. But quite apart from the fact that even in your simple case that&#8217;s not true (I believe that implementation would cause a stack overflow if the input string were long enough), that&#8217;s again missing the point. Let me use again the Facebook puzzles example. To test my code, in all cases except one, I didn&#8217;t write any standard tests. I just wrote two versions of it: I first coded a very simple brute-force solution, that wouldn&#8217;t have been usable in practice because too slow. Then I wrote the optimized algorithm, that was sometimes nearly an order of magnitude more complex. And then I randomly generated thousands of test cases, run them through both algorithms and compared the results. In the end, every piece of code I submitted passed all the Facebook tests the first time, so the technique was certainly effective in removing bugs (Facebook sources say that on average only about 10% of the submissions they receive manage to pass all their tests). And all with a reasonably small effort. Now, you can make up your own mind about whether this tecnique should be classified as a form of testing (comparison testing, as I believe it&#8217;s usually called in the literature) or as a thorough use of postconditions. But I&#8217;m pretty sure that if I had tried to debug my code using only &#8220;example testing&#8221; not only I would have had to do much more work (and very boring work at that), but I wouldn&#8217;t have got anywhere close to the same level of testing.</p>
<p>In general, while I agree that &#8220;example testing&#8221; is in many case necessary, and that you can get reasonably bug-free code with it alone if you work hard enough at it, I also believe you&#8217;ll get better result with significantly less effort if you combine it with assertions/contracts and comparison testing (and maybe other techniques).</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: matteo				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-94234</link>
		<dc:creator><![CDATA[matteo]]></dc:creator>
		<pubDate>Sun, 03 Jul 2011 12:59:28 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-94234</guid>
					<description><![CDATA[Hi Mario,

it&#039;s true that PRE and POST assertions don&#039;t need to specify the output completely.  But then it&#039;s difficult to decide when a method has been specified precisely enough.  Do we stop refining our assertions when they get &quot;too difficult&quot; to refine?  If I assert that for &quot;squeeze&quot; the output string length must be ≤ than the input string length, would it give me much value?  Many assertions that are very easy to write are not worth much.

On the other hand, a test proves that the method works correctly in 1 concrete case.  If I choose the case well, it will give me confidence that many other similar cases work correctly.

You say that you use a lot of assertions in your code and find them extremely useful.  Do you write the assertions before the code?  Do you find that the usefulness comes from the insight that comes when you write them, or from the runtime checks?]]></description>
		<content:encoded><![CDATA[<p>Hi Mario,</p>
<p>it&#8217;s true that PRE and POST assertions don&#8217;t need to specify the output completely.  But then it&#8217;s difficult to decide when a method has been specified precisely enough.  Do we stop refining our assertions when they get &#8220;too difficult&#8221; to refine?  If I assert that for &#8220;squeeze&#8221; the output string length must be ≤ than the input string length, would it give me much value?  Many assertions that are very easy to write are not worth much.</p>
<p>On the other hand, a test proves that the method works correctly in 1 concrete case.  If I choose the case well, it will give me confidence that many other similar cases work correctly.</p>
<p>You say that you use a lot of assertions in your code and find them extremely useful.  Do you write the assertions before the code?  Do you find that the usefulness comes from the insight that comes when you write them, or from the runtime checks?</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Mario				</title>
				<link>http://matteo.vaccari.name/blog/archives/602/comment-page-1#comment-94209</link>
		<dc:creator><![CDATA[Mario]]></dc:creator>
		<pubDate>Sat, 02 Jul 2011 13:15:09 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602#comment-94209</guid>
					<description><![CDATA[I&#039;m not a DBC practitioner, at least not in the form proposed by Bertrand Mayer, but I do tend to use a lot of assertions in my code, and I find them extremely useful.

What I think you&#039;re missing here is that assertions, postconditions and class invariants don&#039;t have to completely specify a method&#039;s behaviour: they can be very useful even if they check some necessary but not sufficient conditions on the result. So you can just write the parts of a contract that are easy to write, and ignore the rest. This is analogous to what happens with tests: the mere fact that your squeeze function returns the correct value for the input &quot;aaabbccccaa&quot; doesn&#039;t mean it will always return the correct value. In other words, passing all tests is a necessary but not sufficient condition for the correctness of piece of code. But that doesn&#039;t mean carefully chosen tests are not useful. So why should it be any different for contracts?

And if you subscribe to this view, you&#039;ll find that one nice thing about assertions/preconditions/postconditions/... is that writing them requires very little effort (while testing often involves writing a lot of code) and that they have a pretty high ROI. So why not use them alongside testing?]]></description>
		<content:encoded><![CDATA[<p>I&#8217;m not a DBC practitioner, at least not in the form proposed by Bertrand Mayer, but I do tend to use a lot of assertions in my code, and I find them extremely useful.</p>
<p>What I think you&#8217;re missing here is that assertions, postconditions and class invariants don&#8217;t have to completely specify a method&#8217;s behaviour: they can be very useful even if they check some necessary but not sufficient conditions on the result. So you can just write the parts of a contract that are easy to write, and ignore the rest. This is analogous to what happens with tests: the mere fact that your squeeze function returns the correct value for the input &#8220;aaabbccccaa&#8221; doesn&#8217;t mean it will always return the correct value. In other words, passing all tests is a necessary but not sufficient condition for the correctness of piece of code. But that doesn&#8217;t mean carefully chosen tests are not useful. So why should it be any different for contracts?</p>
<p>And if you subscribe to this view, you&#8217;ll find that one nice thing about assertions/preconditions/postconditions/&#8230; is that writing them requires very little effort (while testing often involves writing a lot of code) and that they have a pretty high ROI. So why not use them alongside testing?</p>
]]></content:encoded>
						</item>
			</channel>
</rss>
