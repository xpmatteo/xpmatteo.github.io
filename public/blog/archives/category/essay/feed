<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>Essay &#8211; Extreme Enthusiasm</title>
	<atom:link href="http://matteo.vaccari.name/blog/archives/category/essay/feed" rel="self" type="application/rss+xml" />
	<link>http://matteo.vaccari.name/blog</link>
	<description>Extreme enthusiasm</description>
	<lastBuildDate>
	Wed, 08 Jan 2020 14:48:28 +0000	</lastBuildDate>
	<language>en-US</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.1.1</generator>
	<item>
		<title>Bureaucratic tests</title>
		<link>http://matteo.vaccari.name/blog/archives/972</link>
				<comments>http://matteo.vaccari.name/blog/archives/972#respond</comments>
				<pubDate>Mon, 28 Mar 2016 16:00:53 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Essay]]></category>
		<category><![CDATA[Fundamentals]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=972</guid>
				<description><![CDATA[The TDD cycle should be fast! We should be able to repeat the red-green-refactor cycle every few minutes. This means that we should work in very small steps. Kent Beck in fact is always talking about &#8220;baby steps.&#8221; So we should learn how to make progress towards our goal in very small steps, each one [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>The TDD cycle should be fast!  We should be able to repeat the red-green-refactor cycle every few minutes.  This means that we should work in very small steps.  Kent Beck in fact is always talking about &#8220;baby steps.&#8221;  So we should learn how to make progress towards our goal in very small steps, each one taking us a little bit further.  Great!  How do we do that?</p>
<h3 id="example_1_testing_that_8220it8217s_an_object8221">Example 1: Testing that &#8220;it&#8217;s an object&#8221;</h3>
<p>In the quest for &#8220;small steps&#8221;, I sometimes see recommendations that we write things like these:</p>
<pre><code>it("should be an object", function() {
  assertThat(typeof chat.userController === 'object')
});
</code></pre>
<p>which, of course, we can pass by writing</p>
<pre><code>chat.userController = {}
</code></pre>
<p>What is the next &#8220;baby step&#8221;?</p>
<pre><code>it("should be a function", function() {
  assertThat(typeof chat.userController.login === 'function')
});
</code></pre>
<p>And, again, it&#8217;s very easy to make this pass.</p>
<pre><code>chat.userController = { login: function() {} }
</code></pre>
<p>I think these are <strong>not the right kind of &#8220;baby steps&#8221;</strong>.  These tests give us very little value.</p>
<p>Where is the value in a test?  In my view, a test gives you two kinds of value:</p>
<ol>
<li>Verification value, where I get assurance that the code does what I expect.  This is the tester&#8217;s perspective.</li>
<li>Design feedback, where I get information on the quality of my design.  And this is the programmers&#8217;s perspective.</li>
</ol>
<p>I think that in the previous two tests, we didn&#8217;t get any verification value, as all we were checking is the behaviour of the <code>typeof</code> operator.  And we didn&#8217;t get any design feedback either.  We checked that we have an object with a method; this does not mean much, because any problem can be solved with objects and methods.  It&#8217;s a bit like judging a book by checking that it contains written words.  What matters is what the words mean.  In the case of software, what matters is what the objects do.</p>
<h3 id="example_2_testing_ui_structure">Example 2: Testing UI structure</h3>
<p>Another example: there are tutorials that suggest that we test an Android&#8217;s app UI with tests like this one:</p>
<pre><code>public void testMessageGravity() throws Exception {
  TextView myMessage = 
    (TextView) getActivity().findViewById(R.id.myMessage);
  assertEquals(Gravity.CENTER, myMessage.getGravity());
}
</code></pre>
<p>Which, of course, can be made to pass by adding one line to a UI XML file:</p>
<pre><code>&lt;TextView
  android:id="@+id/myMessage"
  <strong>android:gravity="center"</strong>
/&gt;
</code></pre>
<p>What have we learned from this test?  Not much, I&#8217;m afraid.</p>
<h3 id="example_3_testing_a_listener">Example 3: Testing a listener</h3>
<p>This last example is sometimes seen in GUI/MVC code.  We are developing a screen of some sort, and we try to make progress towards the goal of &#8220;when I click this button, something interesting happens.&#8221;  So we write something like this:</p>
<pre><code>@Test
public void buttonShouldBeConnectedToAction() {
    assertEquals(button.getActionListeners().length, 1);
    assertTrue(button.getActionListeners()[0] 
                 instanceof ActionThatDoesSomething);
}
</code></pre>
<p>Once again, this test does not give us much value.</p>
<h3 id="bureaucracy">Bureaucracy</h3>
<p>The above tests are all examples of what Keith Braithwaithe calls &#8220;pseudo-TDD&#8221;:</p>
<ol>
<li>Think of a solution</li>
<li>Imagine a bunch of classes and functions that you just know youâ€™ll need to implement (1)</li>
<li>Write some tests that assert the existence of (2)</li>
<li>[&#8230; go read <a href="https://cumulative-hypotheses.org/2011/08/30/tdd-as-if-you-meant-it/">Keith&#8217;s article</a> for the rest of his thoughts on the subject.]</li>
</ol>
<p>In all of the above examples, we start by thinking of a line of production code that we want to write.  Then we write a test that asserts that that line of code exists.  This test does nothing but <strong>give us permission</strong> to write that line of code: it&#8217;s just bureaucracy!  </p>
<p>Then we write the line of code, and the test passes. What have we accomplished?  A false sense of progress; a false sense of &#8220;doing the right thing&#8221;.  In the end, all we did was wasting time.  </p>
<p>Sometimes I hear developers claim that they took longer to finish, because they had to write the tests.  To me, this is nonsense: I write tests to go faster, not slower.  Writing useless tests slows me down.  If I feel that testing makes me slower, I should probably reconsider how I write those tests: I&#8217;m probably writing bureaucratic tests.</p>
<h3 id="valuable_tests">Valuable tests</h3>
<p>Bureaucratic tests are about <strong>testing a bit of solution</strong> (that is, a bit of the implementation of a solution).  Valuable test are about <strong>solving a little bit of the problem</strong>.  Bureaucratic tests are usually testing structure; valuable tests are always about testing behaviour.  The right way to do baby steps is to break down <strong>the problem</strong> in small bits (not the solution).  If you want to do useful baby steps, start by writing a list of all the tests that you think you will need.</p>
<p>In <em>Test-Driven Development: by Example</em>, Kent Beck attacks the problem of implementing multi-currency money starting with this to-do list:</p>
<pre><code>$5 + 10 CHF = $10 if rate is 2:1
$5 * 2 = $10
</code></pre>
<p>Note that these tests are nothing but small slices of the problem.  In the course of developing the solution, many more tests are added to the list.</p>
<p>Now you are probably wonder what would I do, instead of the bureaucratic tests that I presented above.  In each case, I would start with a simple example of what the software should do.  What are the responsibilities of the <code>userController</code>?  Start there.  For instance:</p>
<pre><code>it("logs in an existing user", function() {
  var user = { nickname: "pippo", password: "s3cr3t" }
  chat.userController.addUser user

  expect(chat.userController.login("pippo", "s3cr3t")).toBe(user)
});
</code></pre>
<p>In the case of the Android UI, I would probably test it by looking at it; the looks of the UI have no behaviour that I can test with logic.  My test passes when the UI &#8220;looks OK&#8221;, and that I can only test by looking at it (see also <a href="https://blog.8thlight.com/uncle-bob/2013/03/06/ThePragmaticsOfTDD.html">Robert Martin&#8217;s opinion on when not to TDD</a>).  I suppose that some of it can be automated with <a href='http://www.agileday.it/2015/sessions/snapshot-testing-su-ios/'>snapshot testing</a>, which is a variant of the &#8220;golden master&#8221; technique.</p>
<p>In the case of the GUI button listener, I would not test it directly.  I would probably write an end-to-end test that proves that when I click the button, something interesting happens.  I would probably also have more focused tests on the behaviour that is being invoked by the listener.</p>
<h3 id="conclusions">Conclusions</h3>
<p>Breaking down a problem into baby steps means that we break in very small pieces the problem to solve, not the solution.  Our tests should always speak about bits of the problem; that is, about things that the customer actually asked for.  Sometimes we need to start by solving an arbitrarily simplified version of the original problem, like Kent Beck and Bill Wake do in <a href='http://xp123.com/articles/slicing-functionality-alternate-paths/'>this article I found enlightening</a>; but it&#8217;s always about testing the problem, not the solution!</p>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/972/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>A fundamental design move</title>
		<link>http://matteo.vaccari.name/blog/archives/856</link>
				<comments>http://matteo.vaccari.name/blog/archives/856#respond</comments>
				<pubDate>Thu, 30 May 2013 16:19:44 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Essay]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=856</guid>
				<description><![CDATA[Pardon me if the content of this post looks obvious to you. It took me years to understand this! When doing incremental design, I found that there is one fundamental move that makes design emerge. It is I recognize that one thing has more than one responsibility; then I separate the responsibilities by splitting the [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Pardon me if the content of this post looks obvious to you.  It took me years to understand this!</p>
<p>When doing incremental design, I found that there is one fundamental move that makes design emerge.  It is </p>
<style type="text/css">
  ol>li {
    list-style-type: lower-alpha;
  }
</style>
<ol>
<li>I recognize that one thing has more than one responsibility; </li>
<li>then I separate the responsibilities by splitting the thing into two or more smaller things;</li>
<li>and I connect the smaller things with the proper degree of coupling.</li>
</ol>
<p>For instance, in the description of the domain of the game Monopoly we have this sentence:</p>
<blockquote><p>    A player takes a turn by rolling two dice and moving around the board accordingly.
</p></blockquote>
<p>A straightforward translation of this into code is</p>
<pre>
class Player {
  // ...
  public void takeTurn() {
    int result = Math.random(6) + Math.random(6);
    this.position = (this.position + result) % 40;
  }      
}
</pre>
<p>Can you see that Player#takeTurn() does two things?  You can see this from the beginning by the wording: &#8220;by rolling two dice *and* moving around the board&#8221;. </p>
<p>You can also see it when you try to write the test:</p>
<pre>
@Test public void playerTakesTurn() {
  Player player = new Player();
  assertEquals(0, player.position()); // initial position
  
  player.takeTurn();
  assertEquals(???, player.position()); // how should I know???
}
</pre>
<p>We can&#8217;t write the last assertion because we have no control over the dice.</p>
<p>The standard way to solve this is to move the responsibility of extracting a random result to a separate class.  </p>
<pre>
@Test public void playerTakesTurn() {
  Dice dice = new Dice();
  Player player = new Player(dice);
  //...
}

class Player {
  public void takeTurn() {
    int result = this.dice.roll();
    this.position = (this.position + result) % 40;
  }      
}
</pre>
<p>This still does not solve our problem, since Dice#roll() will still produce a random result that we have no control over.  But now we have the option of making the coupling between Player and Dice weaker, by making Dice an interface and passing a fake Dice implementation that will return the result that we want:</p>
<pre>
@Test public void playerTakesTurn() {
  Dice dice = new FakeDiceReturning(7);
  Player player = new Player(dice);
  assertEquals(0, player.position()); // initial position

  player.takeTurn();
  assertEquals(7, player.position()); // now it's easy
}
</pre>
<p>This design move, that is almost forced by the need to write a clear test, has a number of advantages:</p>
<ul>
<li>Now we have the option to pass different dice implementation.  If the rules ever called for using different kinds of dice (for instance, 8-sided dice) we would not need to change the Player class at all.</li>
<li>Now we can test the Dice implementation separately.  We might thus discover the bug in the above random number generation code.  (did you see it?) :-)</li>
</ul>
<p>So, to summarize, the fundamental design move is in three steps:</p>
<ol>
<li>You realize a portion of code has two responsibilities, perhaps because the test is hard to write.</li>
<li>You separate the portion of code in two parts; this is usually some form of &#8220;<em>extract method</em>&#8220;.</li>
<li>You&#8217;re not finished yet, because you still have to decide what kind of coupling you want between the two parts.  Usually, a simple <em>extract method</em> will produce a coupling that is too tight.  More work is required to ease the coupling to the degree that you want.</li>
</ol>
<p>It is simply a consequence of the Single Responsibility Principle; but it can also be seen as the or as the application of the &#8220;clarity of intent&#8221; rule in Kent Beck&#8217;s 4 Rules of Simple Design.</p>
<p>Now the interesting thing is that this design move applies not just to methods, but to classes, modules, services and applications!  Whenever you see two things inside one, separate them.  If you applied the right degree of coupling, you will end up with a system that is simpler.  </p>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/856/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>Design tip: Watch how you cut!</title>
		<link>http://matteo.vaccari.name/blog/archives/755</link>
				<comments>http://matteo.vaccari.name/blog/archives/755#respond</comments>
				<pubDate>Mon, 09 Jul 2012 09:14:11 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Essay]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=755</guid>
				<description><![CDATA[The number one design problem I see people do is writing code that is overspecific. By that I mean code that can only be used in one place and can never be reused. Programmers should always try to write code that is generic, reusable and independent from the context where it is used. Design is [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>The number one design problem I see people do is <strong>writing code that is overspecific</strong>.  By that I mean code that can only be used in one place and can never be reused.  Programmers should always try to write code that is generic, reusable and independent from the context where it is used.</p>
<p>Design is (mainly) about breaking the solution in small, manageable pieces.  However, how you do the cut is important; if you cut poorly, you end up with a worse mess than when you had a single monolithic piece.</p>
<p>This is an example I saw last week.  It is Rails-specific but I think non-Rails readers will be able to follow the logic. The application had a general HTML layout that contained something like this:</p>
<pre>
&lt;table&gt;
  &lt;tr&gt;
    &lt;!-- main application content --&gt;
    &lt;td valign=&quot;top&quot;&gt;&lt;%= yield %&gt;&lt;/td&gt;

    &lt;!-- right sidebar --&gt;
    &lt;%= yield :right_sidebar %&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</pre>
<p>Ignore for a second the use of a table for layout (that requires a separate post!)  Can you see the design flaw?</p>
<p>Yes, the flaw is that all pages that want to add something to the right sidebar must remember to wrap it in <code>&lt;td valign=&quot;top&quot;&gt;...&lt;/td&gt;</code>.  Like this:</p>
<pre>
&lt;% content_for :right_sidebar do %&gt;
&lt;td valign=&quot;top&quot;&gt;
  BANNER GOES HERE
&lt;/td&gt;
&lt;% end %&gt;
</pre>
<p>In practice the code that goes in the right sidebar is <strong>dependent on the context</strong> where it is used.  The solution in this case is simple: keep the context in the calling code, not in the called code.  Like this:</p>
<pre>
&lt;table&gt;
  &lt;tr&gt;
    &lt;!-- main application content --&gt;
    &lt;td valign=&quot;top&quot;&gt;&lt;%= yield %&gt;&lt;/td&gt;

    &lt;!-- right sidebar --&gt;
    &lt;td valign=&quot;top&quot;&gt;
      &lt;%= yield :right_sidebar %&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</pre>
<p>This has the problem that if the page does not want to put anything in the right banner, it will still have an empty <code>td</code> element.  Fortunately, Rails has a clean solution for this:</p>
<pre>
&lt;table&gt;
  &lt;tr&gt;
    &lt;!-- main application content --&gt;
    &lt;td valign=&quot;top&quot;&gt;&lt;%= yield %&gt;&lt;/td&gt;

    &lt;!-- right sidebar --&gt;
    &lt;% if content_for? :right_sidebar %&gt;
    &lt;td valign=&quot;top&quot;&gt;
      &lt;%= yield :right_sidebar %&gt;
    &lt;/td&gt;
    &lt;% end %&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</pre>
<p>The code that uses the right sidebar is now simplified to </p>
<pre>
&lt;% content_for :right_sidebar do %&gt;
  BANNER GOES HERE
&lt;% end %&gt;
</pre>
<p>And this code will not have to change when the application layout is changed to something that does not use tables.</p>
<p>Watch how you cut!</p>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/755/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>Formalism versus Object Thinking</title>
		<link>http://matteo.vaccari.name/blog/archives/713</link>
				<comments>http://matteo.vaccari.name/blog/archives/713#comments</comments>
				<pubDate>Sun, 22 Jan 2012 16:08:48 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Essay]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=713</guid>
				<description><![CDATA[The book Object Thinking makes a very good explanation of the divide between two different, antagonistic modes of thinking. The formalist tradition (in software) values logic and mathematics as design tools. A formalist thinks that documents have objective, intrinsic meaning. Think &#8220;design documents&#8221;; think &#8220;specifications&#8221;. The empirical tradition (the book calls it hermeneutics, but I [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>The book <a href="http://books.google.it/books/about/Object_thinking.html?id=-eJQAAAAMAAJ&amp;redir_esc=y" title="Object thinking - David West - Google Libri">Object Thinking</a> makes a very good explanation of the divide between two different, antagonistic modes of thinking.  The formalist tradition (in software) values logic and mathematics as design tools.  A formalist thinks that documents have objective, intrinsic meaning.  Think &#8220;design documents&#8221;; think &#8220;specifications&#8221;.</p>
<p>The empirical tradition (the book calls it hermeneutics, but I will stick to this less formal name :-) values experimentation.  Empiricists hold that the meaning of a document is a shared, temporary convention between the author and the readers.  Think &#8220;user story&#8221;; think CRC cards; think &#8220;quick design session on the whiteboard.&#8221;</p>
<p>The empiriricists brought us Lisp; the formalists brought us Haskell.  The formalists brought us Algol, Pascal, Ada.  The empiricists brought us C, Perl, Smalltalk.</p>
<p>Empiricists like to explain things with anthropomorphism: &#8220;this object <em>knows</em> this and <em>wants</em> to talk to that other object&#8230;&#8221;  The formalists detest anthropomorphism; see these quotes from <a href="http://lambda-the-ultimate.org/node/264" title="Dijkstra on analogies and anthropomorphism | Lambda the Ultimate">Dijkstra</a>.</p>
<p>As a former minor student of <a href="http://cs-exhibitions.uni-klu.ac.at/index.php?id=31" title="Burroughs Corporation">the best formalist tradition</a> there is, and a current student of the Object Thinking tradition, I think I&#8217;m qualified to comment.  Please don&#8217;t take my notes as meaning that the formalist tradition sucks; I certainly don&#8217;t think this.  I&#8217;m interested in highlighting differences.  I think a good developer should <strong>learn from both schools</strong>.</p>
<p>Formalists aim to bring clarity of thought by leveraging mathematical thinking.</p>
<p>Object thinking aims to bring clarity of thought by leveraging spatial reasoning, metaphor, intuition, and other modes of thinking.  </p>
<p>It is well known that mathematical thinking is powerful.  It&#8217;s also more difficult to learn and use.  One example that was <a href="http://www.cs.utexas.edu/~EWD/transcriptions/EWD10xx/EWD1036.html" title="E.W. Dijkstra Archive: On the cruelty of really teaching computing science (EWD 1036)">a favourite of Dijkstra</a> is the problem of <a href="http://gurmeet.net/puzzles/tiling-a-chessboard-with-dominoes/" title="Tiling a Chessboard with Dominoes">covering a chessboard with dominoes</a> when the opposite corners of the chessboards were removed.  If we try to prove that it&#8217;s impossible by &#8220;trying&#8221; to do it or simulating it, we&#8217;d quickly get bogged down.  On the other hand, there&#8217;s a very simple and nice proof that shows that it&#8217;s impossible.  Once you get that idea, you have power :-)</p>
<p>An even more striking example is in <a href="http://www.cs.utexas.edu/~EWD/transcriptions/EWD09xx/EWD980.html" title="E.W. Dijkstra Archive: The strange case of The Pigeon-hole Principle (EWD 980)">this note from Dijkstra</a> on the proof method called &#8220;pigeonhole principle&#8221;.  Dijkstra finds that the name &#8220;pigeon-hole principle&#8221; is unfortunate, as is the idea to imagine &#8220;holes&#8221; and a process of filling them with &#8220;pigeons&#8221; until you find that some pigeon has no hole.  The process is vivid and easy to understand; yet it is limiting.  Dijkstra shows in this note how to define the principle in a more simple and powerful way: </p>
<blockquote><p>
  For a non-empty, finite bag of numbers, the maximum value is at least the average value.
</p></blockquote>
<p>This formulation is simple (<a href="http://www.fcgarage.com/2009/05/the-magic-suitcase.html" title="The Magic Suitcase - FC Garage by Francesco Cirillo">but not easy</a>!)  Armed with this formulation, Dijkstra explains how he used this principle to solve on the spot a combinatorial problem about Totocalcio that a collegue of his could not solve with pen and paper.  He also explains how he used it to solve a generalization of the problem, which would not be easy to prove with the &#8220;object-oriented&#8221; version of the principle.</p>
<p>I think this note presents the contrast between formalism and empiricism vividly.  If you put in the effort to internalize the formal tool, that which was difficult becomes easy, and you can solve a whole new level of problems.</p>
<p>On the other hand, the formalists do now always win :-)  Formalists reject the idea of making tests the cornerstone of software development.  In my opinion they are squarely wrong; <em>examples</em> are the primary tools to do software development, and you can&#8217;t even understand if a specification is correct until you *test* it with examples.</p>
<p>The one thing that boths camps have in common is that they are both minority arts.  Real OOP is almost as rare as Dijkstra-style program derivation.  The common industrial practice is whateverism :-)</p>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/713/feed</wfw:commentRss>
		<slash:comments>2</slash:comments>
							</item>
		<item>
		<title>On knowing what you&#8217;re doing</title>
		<link>http://matteo.vaccari.name/blog/archives/645</link>
				<comments>http://matteo.vaccari.name/blog/archives/645#respond</comments>
				<pubDate>Sun, 09 Oct 2011 19:12:17 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Essay]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=645</guid>
				<description><![CDATA[I&#8217;d like to share this quote from E.W.Dijkstra: When the design of the THE Multiprogramming System neared its completion the University&#8217;s EL X8 was getting installed, but it had not been paid yet, and we hardly had access to it because the manufacturer had to put it to the disposal of an American software house [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I&#8217;d like to share this quote from E.W.Dijkstra:</p>
<blockquote><p>
When the design of the THE Multiprogramming System neared its completion the University&#8217;s EL X8 was getting installed, but it had not been paid yet, and we hardly had access to it because the manufacturer had to put it to the disposal of an American software house that was supposed to write a COBOL implementation for the EL X8. They were program testing all the time, and we let it be known that if occasionally we could have the virgin machine for a few minutes, we would appreciate it. They were nice guys, and a few times per week we would get an opportunity for our next test run. We would enter the machine room with a small roll of punched paper tape, and a few minutes later we would leave the machine room with the output we wanted. I remember it vividly because when they realized what we were achieving, our minimal usage of the machine became more and more frustrating for them. I don&#8217;t think their COBOL implementation was ever completed.<br />
<cite><a href="http://www.cs.utexas.edu/~EWD/index13xx.html">EWD1303</a>,  <em>My recollections of operating systems design</em></cite>
</p></blockquote>
<p>I can picture Dijkstra and his collegues working with paper and blackboards and thinking hard about how they were writing their software.  They came into the room and their software <strong>just worked</strong>.  And I can picture the Cobol crew in a furious vicious circle of code-and-fix; their growing frustration and despair. That was about 1960: no books on software design existed back then. For that matter, no books on compiler writing existed either.  </p>
<p>Could the Cobol crew have done better? Absolutely. In 1954, the FORTRAN team led by <a href="http://en.wikipedia.org/wiki/John_Backus">John Backus</a> produced a compiler that reportedly wrote code almost as good as hand-written.  How could the poor Cobol crew have done something as good or at least good enough?</p>
<p>My answer: by <em>designing</em> their software. By breaking the thing into parts (modules) and developing each one separately. By using analogies from other engineering disciplines; by using metaphors.  I know this is all obvious to us in 2011 as we all know about module decomposition and the use of metaphors and coupling and cohesion.  But is it really obvious?  Really?</p>
<p>What I see is that modern-day software teams today can *still* be divided in two kinds: the Dijkstra-crew kind and the Cobol-crew kind.  Those who are in control and produce reasonably good software within reasonable resources and whose code is reasonably clean;  and those who toil away late hours and produce late and buggy software, with no design, or perhaps with an ineffective, we-dont-really-believe-in-it design and crappy code.</p>
<p>Which do you want to be?  What will you do to become it?</p>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/645/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>Design by Contract vs. Test-Driven Development</title>
		<link>http://matteo.vaccari.name/blog/archives/602</link>
				<comments>http://matteo.vaccari.name/blog/archives/602#comments</comments>
				<pubDate>Sat, 28 May 2011 09:54:25 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Essay]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=602</guid>
				<description><![CDATA[A great many years ago I was fascinated by Bertrand Meyer&#8217;s book &#8220;Object Oriented Program Construction.&#8221; One of the many remarkable things in that book is the idea of &#8220;Design By Contract&#8221;, where you specify what a method does by means of a logical pre&#8211; and post&#8211;condicion. Consider the square root function: pre: x &#8805; [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>A great many years ago I was fascinated by Bertrand Meyer&#8217;s book &#8220;Object Oriented Program Construction.&#8221;  One of the many remarkable things in that book is the idea of &#8220;Design By Contract&#8221;, where you specify what a method does by means of a logical pre&ndash; and post&ndash;condicion.  Consider the square root function:</p>
<pre>
  pre: x &ge; 0
  post: abs(y*y - x) &lt; epsilon
</pre>
<p>This is a very good specification:</p>
<ul>
<li>It&#8217;s efficiently executable.</li>
<li>The intent is clear.</li>
<li>Gives no hint about how to implement it, i.e., it does not contain design ideas.</li>
</ul>
<p>Now I&#8217;m reading the <a href="http://leansoftwareengineering.com/ksse/scrum-ban/" title="Scrum-ban | Lean Software Engineering">Scrumban</a> book by Corey Ladas.  One thing Corey says is that Test-Driven Development is good, but not as good as Design By Contract; in fact, he says, TDD might be a stepping stone to DBC.  </p>
<p><span id="more-602"></span></p>
<p>I have never met someone who does DBC.  This by itself does not mean a lot, as I&#8217;m not widely travelled, in working experience.  I&#8217;d be quite interested in reading experiences about this.  Anyway I suspect that there are fundamental reasons why it&#8217;s not widely practiced.  My hypothesis is that <strong>the square root is an exceptionally good DBC example, but most functions are not as easily specified by contract</strong>.</p>
<p>Consider for example the function &#8220;specified&#8221; by the following TDD-style tests:</p>
<pre>
  it "returns empty string for empty string" do
    assert_equal "", squeeze("")
  end
  
  it "replaces sequences of equal characters with one" do
    assert_equal "abca", squeeze("aaabbccccaa")
  end
</pre>
<p>I think it&#8217;s quite clear how we should implement this function, even though we are given just two examples of its behaviour.  How would we specify it with DBC?  I&#8217;m not sure what is the best way.  I thought about this for a long time (believe me) and this is the best I came up with:</p>
<pre>
pre: true // any string is valid input
post: 
  let s be the input string.
  let s' the output string.
  (&forall; i: s'[i-1] &ne; s'[i])
  &and;
  (&forall; i,j: i &lt; j &rArr; 
    (&exist; k,l: k &lt; l &and; s'[i] = s[k] &and; s'[j] = s[l] ))
  )
</pre>
<p>You read it like this: </p>
<ul>
<li>The output string does not contain consecutive equal values (that was easy!)</li>
<li>Two distinct values in the output string must have been present in the input string and in the same order.</li>
</ul>
<p>Now is this a correct specification?  Can I *prove* that this specification is correct?  Well, this is a specification, so it&#8217;s supposed to be <em>self-evidently correct</em>.  But is it?  I don&#8217;t think it is self evident at all.  I think it takes a bit of thought to understand it.  It&#8217;s not easy to find a way to prove it correct.  One way is to <em>look for counterexamples</em>, that is, find a pair (s,s&#8217;) that satisfies the specification yet contradicts my intuitive notion of what &#8220;squeeze&#8221; should do.  (In fact, I can think of at least two examples that prove that this specification has holes.  Can you find them?)  In other words, it turns out that the only way to convince myself that this specification is correct is by <strong>testing it</strong> on carefully chosen examples!</p>
<p><center><br />
  *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br />
  *<br />
</center></p>
<p>Well it&#8217;s not true that I can&#8217;t find a clearer specification.  Consider this other one:</p>
<pre>
  pre: true
  post: let squeeze behave like f where
    f([]) = []
    f([x]) = [x]
    f([x,x|rest]) = f([x|rest])
    f([x,y|rest]) = x + f([y|rest]) if x &ne; y    
</pre>
<p>The notation [x,y|rest] means &#8220;a string that begins with character x, then character y, then 0 or more other characters.&#8221;  My observations follow.</p>
<p>This is a purely mathematical specification of function squeeze, as pure as  the previous one.    It&#8217;s arguably clearer than the previous specification.  I think this one is correct.  I could test it against a few cases just to make sure, but it seems OK to me.</p>
<p>This spec can be executed efficiently, while checking an input-output pair against the other spec requires quadratic time.</p>
<p>But there&#8217;s a problem; this spec is actually a program.  Once I have this spec I can use *this* for an implementation and work no more.  I already have my implementation.</p>
<p>In conclusion, this is my objection to DBC: I suspect that the square root is an exception; most methods are too complex to specify with pure logic, or require us to write a functional program that solves the problem.  In both cases we are left with the <strong>need to test our specification</strong> on specific examples.</p>
<p>This is why I think TDD is for most purposes more effective than DBC.  In general, <em>concrete examples</em> are by orders of magnitude simpler to write and more self-evident than universal statements.  Most universal statements will have to be tested against examples anyway, or we wouldn&#8217;t be confident in their correctness.  </p>
<p>Long live examples!</p>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/602/feed</wfw:commentRss>
		<slash:comments>16</slash:comments>
							</item>
		<item>
		<title>Anti-FOR tips from the Yahtzee Kata</title>
		<link>http://matteo.vaccari.name/blog/archives/571</link>
				<comments>http://matteo.vaccari.name/blog/archives/571#respond</comments>
				<pubDate>Sat, 14 May 2011 15:47:20 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Design Exercise]]></category>
		<category><![CDATA[Essay]]></category>
		<category><![CDATA[Expressive Code]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=571</guid>
				<description><![CDATA[Again on the Kata Yahtzee, that I blogged about some time ago. If you have not solved the kata at least once, please stop reading this! Get back when you have. *&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;* * Good to see you again! Now that you solved it, you probably know that the naive solution takes many &#8220;for&#8221; loops. Let [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>Again on the <a href="http://codingdojo.org/cgi-bin/wiki.pl?KataYahtzee" title="Coding Dojo Wiki: KataYahtzee">Kata Yahtzee</a>, that I <a href="http://matteo.vaccari.name/blog/archives/311" title="Extreme Enthusiasm  &raquo; Blog Archive   &raquo; Report of the first run of the OCP kata">blogged about</a> some time ago.</p>
<p>If you have not solved the kata at least once, please stop reading this!  Get back when you have.</p>
<p><center><br />
  *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br />
  *<br />
</center></p>
<p>Good to see you again!  Now that you solved it, you probably know that the naive solution takes many &#8220;for&#8221; loops.  Let <em>D</em> be the player dice, represented as <em>an array of die results</em>, e.g., D=(1,6,1,6,4). The naive rules for sixes would be</p>
<p><code></p>
<pre name="code" class="ruby:nogutter:nocontrols">
    def sixes_score 
      sum = 0
      for d in D
        if d == 6
          sum += 6
        end
      end
      return sum
    end
  </pre>
<p></code></p>
<p>This solution involves <em>searching</em> for sixes and adding up.  Why do we need to search?  We need to search because there are many different D that are worth exactly the same for the sixes rule.  For instance, both D=(1,2,3,6,6) and D=(6,6,1,2,3) are worth 12.</p>
<p><span id="more-571"></span></p>
<p>One way to avoid the search is to represent the die rolls in a <em>canonical form</em>, that is a form where two equivalent results are represented in the same way.  The obvious way to obtain a canonical form is to sort D; but in this particular case, we&#8217;d still need to search for sixes.</p>
<p>An alternative canonical form would be to count how many results we have: for instance D=(1,1,3,6,6) would be represented as C = [2,0,1,0,0,2], that is &#8220;two times 1, one time 3, two times 6.&#8221;  The rule for sixes becomes</p>
<p><code></p>
<pre name="code" class="ruby:nogutter:nocontrols">
    def sixes_score
      return 6*C[6]
    end
  </pre>
<p></code></p>
<p>(Note: we take C to be a 1-based array.  It&#8217;s easy to make one in Java or Ruby: use an array of length 7 and ignore index 0.)</p>
<p>The straight rules are also easy, because C is a canonical form for them as well:</p>
<p><code></p>
<pre name="code" class="ruby:nogutter:nocontrols">
    def small_straight_score
      if C == [1,1,1,1,1,0] then 15 else 0
    end
    def large_straight_score
      if C == [0,1,1,1,1,1] then 20 else 0
    end
  </pre>
<p></code></p>
<p>Now, how does this help us with the other rules?  Take the Yahtzee rule, for instance.  The naive solution</p>
<p><code></p>
<pre name="code" class="ruby:nogutter:nocontrols">
    def really_naive_yahtzee_score   
      for (i=1; i &lt; 5 ; i++)
        return 0 if D[i-1] &ne; D[i]
      end
      return 50
    end
  </pre>
<p></code></p>
<p>can be slightly improved by </p>
<p><code></p>
<pre name="code" class="ruby:nogutter:nocontrols">
    def slighly_less_naive_yahtzee_score     
      for d in D
        return 0 if D[0] &ne; d
      end
      return 50
    end
  </pre>
<p></code></p>
<p>Using C does not improve much as we still have to search:</p>
<p><code></p>
<pre name="code" class="ruby:nogutter:nocontrols">
    def still_naive_yahtzee_score
      for c in C
        return 50 if c == 5
      end
      return 0
    end
  </pre>
<p></code></p>
<p>This is because there are many different C that are equivalent with respect to the Yahtzee rule: for instance C = [0,0,0,5,0] and C=[0,5,0,0,0].  Can we apply the same reasoning and find another canonical representation?  Why yes! If we sort C = [0,0,0,5,0] to obtain S = {5,0,0,0,0} the yahtzee rule becomes very simple:</p>
<p><code></p>
<pre name="code" class="ruby:nogutter:nocontrols">
    def cool_yahtzee_score
      if S[0] == 5 then 50 else 0
    end
  </pre>
<p></code></p>
<p>Many other rules are immediately codified this way:</p>
<p><code></p>
<pre name="code" class="ruby:nogutter:nocontrols">
    def four_of_a_kind_score
      if S[0] &ge; 4 then sum(D) else 0
    end
    
    def full_house_score
      if S[0] == 3 &and; S[1] == 2 then 25 else 0
    end
  </pre>
<p></code></p>
<p>The pair rule is a bit more challenging: it is not part of the &#8220;official&#8221; rules but it make for interesting coding :o).  The rule is &#8220;Pair: The player scores the sum of the two highest matching dice. For example, 3, 3, 3, 4, 4  gives 8.&#8221;  Using C requires searching.  Using S would be no good (can you see why?)</p>
<p>Again: can you find a canonical representation for the pair rule so that we don&#8217;t have to search?  Hint: remove &#8220;noise&#8221; to reveal information.</p>
<h3>Conclusion</h3>
<p>It&#8217;s important to find <a href="http://www.antiifcampaign.com/" title="The Anti-IF Campaign">ways to remove IFs</a>.  It&#8217;s also important to find ways to remove FORs!  I <a href="http://matteo.vaccari.name/blog/archives/174" title="Extreme Enthusiasm  &raquo; Blog Archive   &raquo; TDD is not finished until the code speaks">blogged about this</a> before.</p>
<p>We used two ways to remove FORs here:</p>
<ol>
<li>Use canonical representations, like C and S;</li>
<li>Hide them in well-known functions like sort and sum.</li>
</ol>
<p>Our search for canonical forms helps us develop a <em>language</em> for reasoning effectively about our problem domain.  In fact we are <a href="http://alistair.cockburn.us/ASD+book+extract%3A+%22Naur,+Ehn,+Musashi%22" title="Programming as Theory Building">building a little <em>theory</em></a>.</p>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/571/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
		<item>
		<title>Zero is a number</title>
		<link>http://matteo.vaccari.name/blog/archives/438</link>
				<comments>http://matteo.vaccari.name/blog/archives/438#comments</comments>
				<pubDate>Fri, 06 Aug 2010 13:45:05 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Essay]]></category>
		<category><![CDATA[Fundamentals]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=438</guid>
				<description><![CDATA[I won&#8217;t bore you with the story of how long it took for people to recognize that zero is a number. Without zero it would be difficult to explain what is the value of, say, 3 minus 3; we&#8217;d be forced to say that it&#8217;s a &#8220;meaningless&#8221; expression. Funny huh? Yet some developers seem to [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>I won&#8217;t bore you with the story of how long it took for people to recognize that zero is a number.  Without zero it would be difficult to explain what is the value of, say, 3 minus 3; we&#8217;d be forced to say that it&#8217;s a &#8220;meaningless&#8221; expression.  Funny huh?  Yet some developers seem to be stuck to medieval thinking in this respect.  </p>
<p>Have you ever seen code like this?</p>
<p><code></p>
<pre>
public List<Employee> findAllEmployeesByDepartment(int departmentId) {
  String sql = "select * from employees where department_id = ?";
  ResultSet rs = select(sql, department_id);
  if (rs.size() == 0) {
    return null;
  } else {
    // ... convert the recordset to a List and return it
  }
}
</pre>
<p></code></p>
<p>This developer seems to think that an empty List is not a regular list, so he thinks he should return a special value like <code>null</code> to signal that the query returned no values.  This is totally unnecessary.  No, I take it back: this is totally wrong.  You are forcing all callers of <code>findAllEmployeesByDepartment</code> to check for null.  Not only that; this code seem to say that it&#8217;s a totally unnatural and unexpected thing for this query to return no rows.  Soon developers will forget to check for null, and the application will throw <code>NullPointerException</code>s.</p>
<p>A related example is:<br />
<code></p>
<pre>
Foo[] foos = ...;
if (foos.length &gt; 0) {
  for (int i=0; i &lt; foos.length; i++) {
    // do something with foo[i]
  }
}
</pre>
<p></code></p>
<p>Here the developer thinks that they have to treat the case of an empty array separately.  In fact the IF is totally unnecessary.  If the array is empty, the loop would execute zero times anyway.  Java (and C) arrays use asymmetric bounds, which make it easier to write code that does not need to treat a zero-size interval as a special case.</p>
<p>In conclusion: empty collections are perfectly valid collections, and empty arrays are perfectly valid arrays.  It&#8217;s a good idea to write code that doesn&#8217;t treat &#8220;zero&#8221; as a special case.  </p>
<p>This post is part of a series on <a href="/blog/archives/category/fundamentals" title="Extreme Enthusiasm   &raquo; Fundamentals">development fundamentals</a>.</p>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/438/feed</wfw:commentRss>
		<slash:comments>3</slash:comments>
							</item>
		<item>
		<title>TDD is no substitute for knowing what you are doing</title>
		<link>http://matteo.vaccari.name/blog/archives/416</link>
				<comments>http://matteo.vaccari.name/blog/archives/416#comments</comments>
				<pubDate>Tue, 29 Jun 2010 11:26:53 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Essay]]></category>
		<category><![CDATA[Expressive Code]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=416</guid>
				<description><![CDATA[Know your stuff A while ago we had a fun evening at the Milano XPUG writing a Sudoku solver. I blogged about my solution. I&#8217;m not particularly proud of it, in retrospect. The code and the tests are not obvious. I can&#8217;t read any of it and be certain that it works. It does not [&#8230;]]]></description>
								<content:encoded><![CDATA[<h4>Know your stuff</h4>
<p>A while ago we had a fun evening at the <a href="http://milano-xpug.pbworks.com/" title="milano-xpug / FrontPage">Milano XPUG</a> writing a Sudoku solver.  I blogged about <a href="http://matteo.vaccari.name/blog/archives/43" title="Extreme Enthusiasm  &raquo; Blog Archive   &raquo; Sudoku anch&#8217;io">my solution</a>.  I&#8217;m not particularly proud of it, in retrospect.  The code and the tests are not obvious.  I can&#8217;t read any of it and be certain that it works.  It does not speak.</p>
<p>It is true that solving puzzles like Sudoku is quite different from what application programmers do everyday at work.  Why is it that?  The problems that we solve in business applications do not have that mathematical crispness that puzzles have.  Perhaps it&#8217;s because we&#8217;re not good enough at analyzing them and expressing them abstractly.  That would explain why business code is so long, convoluted and expensive.</p>
<p>Anyway, the point I want to make is that it is not satisfying to use the tests in TDD as a crutch for constructing hapazard code that, with a kick here and a few hammer blows there seem to work.  The point of TDD is to *design* code; and a good design shows how and why a solution works.  </p>
<p>I often see people doing katas that involve problems with well-known solutions.  We usually disregard, forget, or ignore the well-known solution! And we keep writing tests and production code until we rig together something that passes the tests.  It&#8217;s painful.  I know.  I too did some of that.</p>
<p>TDD does not work well when we don&#8217;t know what we&#8217;re doing.  Some high-profile XPers failed to ship when TDDing their way with <a href="http://thinkingbox.wordpress.com/2008/09/11/the-consequences-of-shipping/" title="The consequences of shipping &laquo; The thinking box">unfamiliar APIs</a> or <a href="http://ravimohan.blogspot.com/2007/04/learning-from-sudoku-solvers.html" title="One Man Hacking: Learning From Sudoku Solvers">disregarding known solutions</a>.  TDD is no substitute for analyzing a problem, and finding abstractions that make it easy to solve.  TDD without thinking and analyzing and abstracting <em>is not fun!</em>.</p>
<p>It&#8217;s for this reason that there is the XP practice of &#8220;spiking solutions&#8221;, that is, take time to learn how to do something, make experiments, then apply what you learned.  If you know how to do things, you will not spend hours discussing with your pair; you and your pair will grab the keyboard from each other, as <a href="http://cirillosscrapbook.wordpress.com/2008/05/27/mamma-programming/#more-53" title="Mamma Programming &laquo; Cirillo&#039;s Scrapbook">Francesco Cirillo often says</a>.</p>
<h4>A better way</h4>
<p>Consider Sudoku again.  Peter Norvig <a href="http://norvig.com/sudoku.html" title="Solving Every Sudoku Puzzle">solves it</a> in two different ways by using known techniques.  The first solution is depth-first search, which is gueranteed to terminate as the graph of Sudoku states is acyclic.  The other is by constraint propagation.  If I were to do the exercise again, I would try to make the analysis apparent from the code.</p>
<p>Say we want to solve it by depth-first search.  That entails two sub-problems:</p>
<ul>
<li style="list-style-type:none">a) writing a depth-first algorithm</li>
<li style="list-style-type:none">b) writing something that enumerates legal moves in a given Sudoku board</li>
</ul>
<p>I would start by testing the depth-first search algorithm.  I would drive it with an abstract &#8220;tree&#8221; implementation.  This means I could concentrate on the search algorithm without being distracted by the complex details of the Sudoku rules.  </p>
<p>Then I would test-drive the generation of next-moves from a Sudoku position.  That could also be done incrementally.  Can we imagine a simplified Sudoku board?  The full Sudoku is too complex for the first test!  A year ago I would have started by defining a 9 by 9 array of numbers, but now the sheer boredom of defining it would stop me.  Is there a better way?  </p>
<p>Relax.  Think.  Dream.</p>
<p>Think about the game terminology.  As <a href="http://norvig.com/sudoku.html" title="Solving Every Sudoku Puzzle">Norvig says</a>, the game is about <em>units</em> (either a row, a column or a box).  A unit with no empty spaces has no descendant moves.  A unit where a number is missing has the full unit as a descendant move.  A unit where two numbers are missing&#8230; You get the point.</p>
<p>Then work out how to combine descendant moves of two units that share a square.  Think a row and a column.  If the common square is empty, than valid solutions for that square must be valid for both units&#8230;  </p>
<p>The point is to work the problem incrementally.  Try smaller scales first.  Try 2&#215;2 boards.  Make the size of units and the board parametric.  Add the constraint rules one by one, so that you can test them separately.</p>
<h4>Conclusions</h4>
<p>One important principle to apply is &#8220;separation of concerns&#8221;.  Enumerating moves is a problem, and search strategy is another.  By solving them separately, our tests become more clear and to the point.  We gain confidence that we know how and why our code works.</p>
<p>Another way to see this is to decompose a problem in smaller problems; prove with tests that you can solve the subproblems, then prove with tests that you can solve the composition of the subproblems.</p>
<p>When you have a problem that is of fixed size 42, turn that constant into a parameter and solve the problem for N=1, N=2, &#8230; Imagine if the Sudoku board was 100&#215;100 instead of 9&#215;9; would you define a 100&#215;100 matrix in your tests?  Turning these constants into parameters make your code more general, your tests more clear, while making the problem *easier* to solve!</p>
<p>To summarize, what I think is important is</p>
<ul>
<li>Learn data structures, algorithms, known solutions, the proper way of doing things.</li>
<li>Apply separation of concerns.  </li>
<li>Solving a slightly more general problem sometimes is much easier than solving the actual problem</li>
<li>It&#8217;s more fun to work when you know what you&#8217;re doing!</li>
</ul>
<h4 style="margin-top: 6em">Update</h4>
<p>Charlie Poole <a href="http://tech.groups.yahoo.com/group/testdrivendevelopment/message/33042" title="Yahoo! Groups">recently posted this</a> on the TDD mailing list (Emphasis is mine):</p>
<blockquote><p>
I&#8217;ve written elsewhere that I believe attempting to get TDD to &#8220;drive&#8221; the invention of a new algorithm reflects an incorrect understanding of what TDD is for.</p>
<p>TDD allows us to express intent (i.e. design) in a testable manner and to move from intention to implementation very smoothly &#8211; I know of no better way.</p>
<p>OTOH, you <em><strong>have to start out with an intent</strong></em>. In this context, I think that means you need to have some idea of the algorithm you want to implement. TDD will help you implement it and even refine the details of the idea. Writing tests may also inspire you to have further ideas, to deepen the ones you started with or to abandon ideas that are not working out.
</p></blockquote>
<p>Vlad Levin <a href="http://vladimirlevin.blogspot.com/2007/04/tdd-is-not-algorithm-generator.html" title="Vlad's Agile Software Development Blog: TDD Is Not An Algorithm Generator!">blogs thoughtfully</a>:</p>
<blockquote>
<p>  one of the first rules I teach my students when I am doing a TDD workshop or teaching a course is precisely that <strong>TDD is not an algorithm generator</strong>! Solving sudoku is just the kind of problem you want to find an algorithm for first, then implement that algorithm</p>
<p>  [&#8230;]</p>
<p>  So what is the purpose of TDD then? One goal of TDD is to reduce the need to determine ahead of time which classes and methods you&#8217;re going to implement for an entire story. There&#8217;s a large body of shared experience in the developer community that trying to anticipate such things tends to lead to paralysis where nothing useful gets done and/or produces bloated, over-designed code. Instead, you can develop one aspect of the story at a time, using each test to keep yourself moving forward and refactoring the design as you go along
</p></blockquote>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/416/feed</wfw:commentRss>
		<slash:comments>1</slash:comments>
							</item>
		<item>
		<title>A semi-forgotten design principle</title>
		<link>http://matteo.vaccari.name/blog/archives/182</link>
				<comments>http://matteo.vaccari.name/blog/archives/182#respond</comments>
				<pubDate>Fri, 11 Sep 2009 08:41:36 +0000</pubDate>
		<dc:creator><![CDATA[matteo]]></dc:creator>
				<category><![CDATA[Agile]]></category>
		<category><![CDATA[Essay]]></category>

		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=182</guid>
				<description><![CDATA[The common wisdom is that Ruby is slow and Java is fast. In general, it&#8217;s true. But is it always? Look at this simple test. $ cat hello.rb puts "Hello world!" $ ruby hello.rb Hello world! $ time ruby hello.rb Hello world! real 0m0.008s user 0m0.004s sys 0m0.003s $ So it looks like it takes [&#8230;]]]></description>
								<content:encoded><![CDATA[<p>The common wisdom is that Ruby is slow and Java is fast.  In general, it&#8217;s true.  But is it always?  Look at this simple test.<br />
<code></p>
<pre>
$ cat hello.rb 
puts "Hello world!"
$ ruby hello.rb 
Hello world!
$ time ruby hello.rb 
Hello world!

real	0m0.008s
user	0m0.004s
sys	0m0.003s
$
</pre>
<p></code><br />
So it looks like it takes 8ms to run a simple &#8220;hello, world&#8221; in Ruby.  How does Java compare to this?</p>
<p><code></p>
<pre>
$ cat Hello.java 
public class Hello {
    public static void main(String ... args) {
        System.out.println("Hello, world!");
    }
}
$ 
$ javac Hello.java 
$ java Hello
Hello, world!
$ time java Hello
Hello, world!

real	0m0.122s
user	0m0.061s
sys	0m0.028s
$
</pre>
<p></code><br />
Even if we ignore the time it takes to <em>compile</em> the Java program, it looks like running the &#8220;Hello, world&#8221; in Java takes <strong>15 times longer</strong> than Ruby.  This is due to the long startup time of the Java Virtual Machine.  The times you see here are taken on my MacBook Pro; they will be different on other operating systems, but not much different. </p>
<p>So what, you will say?  &#8220;The startup time is not important!  As soon as the JVM is up and running, Java can run circles around Ruby.&#8221;  </p>
<p>I don&#8217;t agree that startup times are not important.  The startup time for Java becomes much worse when you run complex applications.  A vanilla Tomcat with no web applications installed takes about <strong>one minute</strong> to start up.  Compare with Webrick, the Ruby web server, that is up and running with my web application in <strong>3&nbsp;seconds</strong>.  The difference in startup times makes all the difference in the world when you&#8217;re developing software.  It takes at least one minute, often much longer, to start up a Java application so that I can try it.  There are times when you&#8217;re developing an application when you need to test it after each tiny change.  It&#8217;s very difficult to do that in Java.  The problem is made much worse by the fact that in general Java &#8220;containers&#8221; can&#8217;t reload changed classes without a restart.  (Webrick can do that.)</p>
<p>What, you will say?  &#8220;Matteo gave up TDD!  He tests applications manually by clicking around like a monkey!&#8221;  No, really, it&#8217;s not like this.  I always write production code with TDD.  That does not mean that you *never* test your stuff manually on the live application.  Quite the opposite: there is a danger, with new converts to unit testing, that we trust our tests too much.  I&#8217;ve seen people declare a story &#8220;finished&#8221; when all the unit tests are green, without ever checking if it <strong>really works</strong>!  And of course, if you never test it manually, it will not work.  There is a need for manual testing (some call it exploratory testing), even if you&#8217;re Kent Beck or Misko Every.</p>
<p>So I hope you&#8217;ll agree with me that short startup times are important for developers.  But there are other implications.  The fact that it takes a lot of time to startup a Java application means that Java developers are trained to <strong>write applications in a single JVM process</strong>.  For instance, we often see dozens of web applications running in a single Tomcat.  If you need concurrent operations, the solution is always to run more threads within the same process.  And there is a big problem with this.</p>
<p>The operating system&#8217;s concept of a &#8220;process&#8221; is a very useful one.  A &#8220;process&#8221; is a bundle of threads and resources: memory, open files, network connections, and the like.  A process in Unix or Windows is a watertight compartment.  When a process terminates, *all* of its resources are released.  A process cannot easily corrupt the state of another process.  A process can be given limits on how much memory or CPU it can take.  It&#8217;s very useful to organize a concurrent application as a set of cooperating operating system processes.  That&#8217;s the way the Apache Http server works, and that is a remarkably reliable software.  It&#8217;s also one of the smart ideas in the Chrome browser, to run each tab in a separate process.</p>
<p>It&#8217;s a good design principle to have many small modules communicating with well-defined interfaces, rather than a single monolith where all the threads can interact in unforeseen ways.  It&#8217;s also the way of Unix to design applications as collections of small communicating processes.  Which makes me wonder how could Sun ever get us to believe that it&#8217;s a good idea to put all of our eggs in a single, huge process.  Should not Sun be the champion of the Unix way?  But I digress.</p>
<p>In conclusion, I claim that designing applications with small cooperating operating system processes is a good principle.  Java current practice runs against this, but it need not be.</p>
]]></content:encoded>
							<wfw:commentRss>http://matteo.vaccari.name/blog/archives/182/feed</wfw:commentRss>
		<slash:comments>0</slash:comments>
							</item>
	</channel>
</rss>
