<!DOCTYPE html>
<html>


<!-- Mirrored from matteo.vaccari.name/blog/archives/602 by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 24 Sep 2021 10:24:45 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="initial-scale=1">

<title>Extreme Enthusiasm  &raquo; Blog Archive   &raquo; Design by Contract vs. Test-Driven Development</title>

<meta name="generator" content="WordPress 5.1.1" /> <!-- leave this for stats -->

<link rel="stylesheet" href="../wp-content/themes/mv2/style.css" type="text/css" media="screen" />
<link rel="alternate" type="application/rss+xml" title="Extreme Enthusiasm RSS Feed" href="../feed" />
<link rel="pingback" href="../xmlrpc.php" />

<link rel='dns-prefetch' href='http://s.w.org/' />
<link rel="alternate" type="application/rss+xml" title="Extreme Enthusiasm &raquo; Design by Contract vs. Test-Driven Development Comments Feed" href="602/feed" />
		<script type="text/javascript">
			window._wpemojiSettings = {"baseUrl":"https:\/\/s.w.org\/images\/core\/emoji\/11.2.0\/72x72\/","ext":".png","svgUrl":"https:\/\/s.w.org\/images\/core\/emoji\/11.2.0\/svg\/","svgExt":".svg","source":{"concatemoji":"http:\/\/matteo.vaccari.name\/blog\/wp-includes\/js\/wp-emoji-release.min.js?ver=5.1.1"}};
			!function(a,b,c){function d(a,b){var c=String.fromCharCode;l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,a),0,0);var d=k.toDataURL();l.clearRect(0,0,k.width,k.height),l.fillText(c.apply(this,b),0,0);var e=k.toDataURL();return d===e}function e(a){var b;if(!l||!l.fillText)return!1;switch(l.textBaseline="top",l.font="600 32px Arial",a){case"flag":return!(b=d([55356,56826,55356,56819],[55356,56826,8203,55356,56819]))&&(b=d([55356,57332,56128,56423,56128,56418,56128,56421,56128,56430,56128,56423,56128,56447],[55356,57332,8203,56128,56423,8203,56128,56418,8203,56128,56421,8203,56128,56430,8203,56128,56423,8203,56128,56447]),!b);case"emoji":return b=d([55358,56760,9792,65039],[55358,56760,8203,9792,65039]),!b}return!1}function f(a){var c=b.createElement("script");c.src=a,c.defer=c.type="text/javascript",b.getElementsByTagName("head")[0].appendChild(c)}var g,h,i,j,k=b.createElement("canvas"),l=k.getContext&&k.getContext("2d");for(j=Array("flag","emoji"),c.supports={everything:!0,everythingExceptFlag:!0},i=0;i<j.length;i++)c.supports[j[i]]=e(j[i]),c.supports.everything=c.supports.everything&&c.supports[j[i]],"flag"!==j[i]&&(c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&c.supports[j[i]]);c.supports.everythingExceptFlag=c.supports.everythingExceptFlag&&!c.supports.flag,c.DOMReady=!1,c.readyCallback=function(){c.DOMReady=!0},c.supports.everything||(h=function(){c.readyCallback()},b.addEventListener?(b.addEventListener("DOMContentLoaded",h,!1),a.addEventListener("load",h,!1)):(a.attachEvent("onload",h),b.attachEvent("onreadystatechange",function(){"complete"===b.readyState&&c.readyCallback()})),g=c.source||{},g.concatemoji?f(g.concatemoji):g.wpemoji&&g.twemoji&&(f(g.twemoji),f(g.wpemoji)))}(window,document,window._wpemojiSettings);
		</script>
		<style type="text/css">
img.wp-smiley,
img.emoji {
	display: inline !important;
	border: none !important;
	box-shadow: none !important;
	height: 1em !important;
	width: 1em !important;
	margin: 0 .07em !important;
	vertical-align: -0.1em !important;
	background: none !important;
	padding: 0 !important;
}
</style>
	<link rel='stylesheet' id='wp-block-library-css'  href='../wp-includes/css/dist/block-library/style.min3c21.css?ver=5.1.1' type='text/css' media='all' />
<link rel='https://api.w.org/' href='../wp-json/index.html' />
<link rel="EditURI" type="application/rsd+xml" title="RSD" href="../xmlrpc0db0.php?rsd" />
<link rel="wlwmanifest" type="application/wlwmanifest+xml" href="../wp-includes/wlwmanifest.xml" /> 
<link rel='prev' title='Feeling like carrying bags of sand' href='593.html' />
<link rel='next' title='Solid design for Rails applications' href='611.html' />
<meta name="generator" content="WordPress 5.1.1" />
<link rel="canonical" href="602.html" />
<link rel='shortlink' href='../indexca7f.html?p=602' />
<link rel="alternate" type="application/json+oembed" href="../wp-json/oembed/1.0/embed0629.json?url=http%3A%2F%2Fmatteo.vaccari.name%2Fblog%2Farchives%2F602" />
<link rel="alternate" type="text/xml+oembed" href="../wp-json/oembed/1.0/embedaea2?url=http%3A%2F%2Fmatteo.vaccari.name%2Fblog%2Farchives%2F602&amp;format=xml" />
</head>
<body>
<div id="page">

<div id="header">
	<h1><a href="../../blog">Extreme Enthusiasm</a></h1>
</div>

<div id='maincontent'>
    <div id='main-col'>

  
		<div class="navigation">
			<div class="alignleft">&laquo; <a href="593.html" rel="prev">Feeling like carrying bags of sand</a></div>
			<div class="alignright"><a href="611.html" rel="next">Solid design for Rails applications</a> &raquo;</div>
		</div>

		<div class="post" id="post-602">
			<h2><a href="602.html" rel="bookmark" title="Permanent Link: Design by Contract vs. Test-Driven Development">Design by Contract vs. Test-Driven Development</a></h2>

			<div class="entrytext">
				<p>A great many years ago I was fascinated by Bertrand Meyer&#8217;s book &#8220;Object Oriented Program Construction.&#8221;  One of the many remarkable things in that book is the idea of &#8220;Design By Contract&#8221;, where you specify what a method does by means of a logical pre&ndash; and post&ndash;condicion.  Consider the square root function:</p>
<pre>
  pre: x &ge; 0
  post: abs(y*y - x) &lt; epsilon
</pre>
<p>This is a very good specification:</p>
<ul>
<li>It&#8217;s efficiently executable.</li>
<li>The intent is clear.</li>
<li>Gives no hint about how to implement it, i.e., it does not contain design ideas.</li>
</ul>
<p>Now I&#8217;m reading the <a href="http://leansoftwareengineering.com/ksse/scrum-ban/" title="Scrum-ban | Lean Software Engineering">Scrumban</a> book by Corey Ladas.  One thing Corey says is that Test-Driven Development is good, but not as good as Design By Contract; in fact, he says, TDD might be a stepping stone to DBC.  </p>
<p><span id="more-602"></span></p>
<p>I have never met someone who does DBC.  This by itself does not mean a lot, as I&#8217;m not widely travelled, in working experience.  I&#8217;d be quite interested in reading experiences about this.  Anyway I suspect that there are fundamental reasons why it&#8217;s not widely practiced.  My hypothesis is that <strong>the square root is an exceptionally good DBC example, but most functions are not as easily specified by contract</strong>.</p>
<p>Consider for example the function &#8220;specified&#8221; by the following TDD-style tests:</p>
<pre>
  it "returns empty string for empty string" do
    assert_equal "", squeeze("")
  end
  
  it "replaces sequences of equal characters with one" do
    assert_equal "abca", squeeze("aaabbccccaa")
  end
</pre>
<p>I think it&#8217;s quite clear how we should implement this function, even though we are given just two examples of its behaviour.  How would we specify it with DBC?  I&#8217;m not sure what is the best way.  I thought about this for a long time (believe me) and this is the best I came up with:</p>
<pre>
pre: true // any string is valid input
post: 
  let s be the input string.
  let s' the output string.
  (&forall; i: s'[i-1] &ne; s'[i])
  &and;
  (&forall; i,j: i &lt; j &rArr; 
    (&exist; k,l: k &lt; l &and; s'[i] = s[k] &and; s'[j] = s[l] ))
  )
</pre>
<p>You read it like this: </p>
<ul>
<li>The output string does not contain consecutive equal values (that was easy!)</li>
<li>Two distinct values in the output string must have been present in the input string and in the same order.</li>
</ul>
<p>Now is this a correct specification?  Can I *prove* that this specification is correct?  Well, this is a specification, so it&#8217;s supposed to be <em>self-evidently correct</em>.  But is it?  I don&#8217;t think it is self evident at all.  I think it takes a bit of thought to understand it.  It&#8217;s not easy to find a way to prove it correct.  One way is to <em>look for counterexamples</em>, that is, find a pair (s,s&#8217;) that satisfies the specification yet contradicts my intuitive notion of what &#8220;squeeze&#8221; should do.  (In fact, I can think of at least two examples that prove that this specification has holes.  Can you find them?)  In other words, it turns out that the only way to convince myself that this specification is correct is by <strong>testing it</strong> on carefully chosen examples!</p>
<p><center><br />
  *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br />
  *<br />
</center></p>
<p>Well it&#8217;s not true that I can&#8217;t find a clearer specification.  Consider this other one:</p>
<pre>
  pre: true
  post: let squeeze behave like f where
    f([]) = []
    f([x]) = [x]
    f([x,x|rest]) = f([x|rest])
    f([x,y|rest]) = x + f([y|rest]) if x &ne; y    
</pre>
<p>The notation [x,y|rest] means &#8220;a string that begins with character x, then character y, then 0 or more other characters.&#8221;  My observations follow.</p>
<p>This is a purely mathematical specification of function squeeze, as pure as  the previous one.    It&#8217;s arguably clearer than the previous specification.  I think this one is correct.  I could test it against a few cases just to make sure, but it seems OK to me.</p>
<p>This spec can be executed efficiently, while checking an input-output pair against the other spec requires quadratic time.</p>
<p>But there&#8217;s a problem; this spec is actually a program.  Once I have this spec I can use *this* for an implementation and work no more.  I already have my implementation.</p>
<p>In conclusion, this is my objection to DBC: I suspect that the square root is an exception; most methods are too complex to specify with pure logic, or require us to write a functional program that solves the problem.  In both cases we are left with the <strong>need to test our specification</strong> on specific examples.</p>
<p>This is why I think TDD is for most purposes more effective than DBC.  In general, <em>concrete examples</em> are by orders of magnitude simpler to write and more self-evident than universal statements.  Most universal statements will have to be tested against examples anyway, or we wouldn&#8217;t be confident in their correctness.  </p>
<p>Long live examples!</p>

				
				<p class="postmetadata alt">
					<small>
						This entry was posted
												on 28 May 2011 at 11:54						and is filed under <a href="category/agile.html" rel="category tag">Agile</a>, <a href="category/essay.html" rel="category tag">Essay</a>.
						You can follow any responses to this entry through the <a href="602/feed">RSS 2.0</a> feed.

													You can <a href="#respond">leave a response</a>, or <a href="602/trackback" rel="trackback">trackback</a> from your own site.

						
					</small>
				</p>

			</div>
		</div>

	
<!-- You can start editing here. -->

	<h3 id="comments">16 Responses to &#8220;Design by Contract vs. Test-Driven Development&#8221;</h3> 

	<ol class="commentlist">

	
		<li class="alt" id="comment-93979">
			<cite>Simone Busoli</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-93979" title="">May 28th, 2011 at 12:14</a> </small>

			<p>I&#8217;m not doing DBC but I think you didn&#8217;t get it completely right.</p>
<p>DBC, as far as I understood it, is about specifying /quantitative/ characteristics of return values (in the case of post-conditions), not about qualitative or semantics. If you have to write the same body of your method in the post conditions then it is certainly wrong.</p>
<p>Post conditions are about &#8220;if you respect pre-conditions, you&#8217;ll get a return value which respects the post-conditions&#8221;. This leaves a lot to be defined, but in your example a meaningful post-condition would simply entail that the return value is a non-empty string, for non-empty inputs.</p>
<p>In the end DBC does not replace TDD, nor testing in general.</p>

		</li>

	
	
		<li class="" id="comment-93980">
			<cite><a href='http://zatoichi.homeip.net/' rel='external nofollow' class='url'>Ilias Bartolini</a></cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-93980" title="">May 28th, 2011 at 13:34</a> </small>

			<p>Hi Matteo,<br />
I tried Eiffel on a small dummy project many years ago.<br />
I agree with all your statements: specification by example is often more readable and easy to modify or maintain. </p>
<p>I think that one missing point is that TDD and DBC are *not* alternative practices.<br />
If I&#8217;m using a language that support DBC I would still write use TDD.</p>
<p>Contracts are code executed at runtime and their constraints checked also in your production code. You still can use tests if you want to execute them, specify examples, drive your emergent design, etc&#8230; still using tests on top of DBC.</p>
<p>One point point why DBC may be considered better (don&#8217;t know if this was Corey intention) is that its &#8220;safety net&#8221; and &#8220;check constraint&#8221; can be more strict than one given writing tests.   </p>
<p>I heard many people saying DBC is more difficult way of programming and developers are not used to that&#8230;  but many people were saying the same thing about TDD many years ago and we found its not true :)</p>
<p>ciao,<br />
Ilias</p>

		</li>

	
	
		<li class="alt" id="comment-93981">
			<cite>matteo</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-93981" title="">May 28th, 2011 at 14:36</a> </small>

			<p>@Simone: yes, I suspect most programmers use DBC as a way to specify necessary constraints (for instance, this parameter must be &gt;0) rather than providing a precise, complete definition of what the function should do.   But if you leave it at that, the value of DBC is small.  I think the value of DBC is not in the runtime assertions; it&#8217;s in the /thought/ that goes in defining the contracts!</p>
<p>@Ilias: Yes, I suppose you can combine the two techniques, and I do think DBC has value.  But I think that formal specification is hard, and we don&#8217;t see enough examples!  Where are the DBC screencasts?  Where can I read a &#8220;DBC Recipes&#8221; handbook?</p>

		</li>

	
	
		<li class="" id="comment-93985">
			<cite><a href='http://jfranzoi.wordpress.com/' rel='external nofollow' class='url'>Jacopo</a></cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-93985" title="">May 29th, 2011 at 23:49</a> </small>

			<p>when I first learnt DBC, one question quickly came to my mind: where do we write contracts? specification or documentation was initial answer, but I later thought automatic tests were an even better idea!</p>
<p>more on examples as a specification media: &#8220;Specification By Examples&#8221;, by (omniscent) Fowler<br />
* <a href="http://martinfowler.com/bliki/SpecificationByExample.html" rel="nofollow">http://martinfowler.com/bliki/SpecificationByExample.html</a></p>
<p>ciao!<br />
-jacopo-</p>

		</li>

	
	
		<li class="alt" id="comment-93987">
			<cite><a href='http://www.carlopescio.com/' rel='external nofollow' class='url'>Carlo Pescio</a></cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-93987" title="">May 31st, 2011 at 19:53</a> </small>

			<p>(this is partially tongue-in-cheek; I&#8217;m not a heavy user of DBC, anyway)</p>
<p>a design method qualifies as a design method :-) when it&#8217;s actually helping/poking you as you shape your code. If it doesn&#8217;t, it&#8217;s not really a design method.</p>
<p>In your case, I would say that DBC is pushing you to stop thinking of squeeze as a function (yeah, I know, it&#8217;s kinda hard :-)).<br />
Once you give up and redefine squeeze as a class, perhaps SqueezedString, you&#8217;ll quickly see that:</p>
<p>&#8211; the invariant of the class is the &#8220;easy part&#8221; of your spec (no consecutive equal values)</p>
<p>&#8211; a Concat( char ch ) method is trivial to implement: if the last char is the same as ch, do nothing; otherwise, append ch.<br />
A useful/robust postcondition for Concat is then equally trivial:<br />
&#8211; ch must indeed be at the end of the string<br />
&#8211; the first len&#8217; characters must be unchanged [where len&#8217; is the lenght before Concat]<br />
&#8211; len&#8217; &lt;= len &lt;= len&#039;+1<br />
(the invariant must still be respected, as usual).<br />
[Note that this is a contract and not an executable spec]</p>
<p>&#8211; if you really want a constructor (or Append method) taking a string, the safest/easier way would then be to base it on Concat. In this case, there is a strong temptation to underspecify the post-condition, lulled by the sense of security of a trivial implementation (a simple loop over a well-specified method). For instance, you may just check that every char in the source string is also in the squeezed string, and ignore the order constraint.</p>
<p>&#8211; of course, a faster implementation based on a string builder might be needed, but the contract can withstand that.</p>
<p>[Slightly] more seriously, every specification technique has its own sweet spot. DBC is hard to apply to functions with &quot;complex&quot; internal logic which cannot be abstracted in a contract, so it may push you to split your function or even to turn it into a class. This is either a boon or a hindrance, depending on how you&#039;re looking at things :-) [and honestly, depending on the problem you&#039;re trying to solve]</p>

		</li>

	
	
		<li class="" id="comment-93989">
			<cite>matteo</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-93989" title="">June 1st, 2011 at 09:21</a> </small>

			<p>@Jacopo: good link, I think Fowler agrees with my post!</p>
<p>@Carlo: thanks for your comment, it&#8217;s insightful.  I didn&#8217;t see that DBC could be pushing towards breaking the function in &#8220;smaller pieces&#8221;, so to speak, that can be specified separately.</p>

		</li>

	
	
		<li class="alt" id="comment-94209">
			<cite>Mario</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-94209" title="">July 2nd, 2011 at 15:15</a> </small>

			<p>I&#8217;m not a DBC practitioner, at least not in the form proposed by Bertrand Mayer, but I do tend to use a lot of assertions in my code, and I find them extremely useful.</p>
<p>What I think you&#8217;re missing here is that assertions, postconditions and class invariants don&#8217;t have to completely specify a method&#8217;s behaviour: they can be very useful even if they check some necessary but not sufficient conditions on the result. So you can just write the parts of a contract that are easy to write, and ignore the rest. This is analogous to what happens with tests: the mere fact that your squeeze function returns the correct value for the input &#8220;aaabbccccaa&#8221; doesn&#8217;t mean it will always return the correct value. In other words, passing all tests is a necessary but not sufficient condition for the correctness of piece of code. But that doesn&#8217;t mean carefully chosen tests are not useful. So why should it be any different for contracts?</p>
<p>And if you subscribe to this view, you&#8217;ll find that one nice thing about assertions/preconditions/postconditions/&#8230; is that writing them requires very little effort (while testing often involves writing a lot of code) and that they have a pretty high ROI. So why not use them alongside testing?</p>

		</li>

	
	
		<li class="" id="comment-94234">
			<cite>matteo</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-94234" title="">July 3rd, 2011 at 14:59</a> </small>

			<p>Hi Mario,</p>
<p>it&#8217;s true that PRE and POST assertions don&#8217;t need to specify the output completely.  But then it&#8217;s difficult to decide when a method has been specified precisely enough.  Do we stop refining our assertions when they get &#8220;too difficult&#8221; to refine?  If I assert that for &#8220;squeeze&#8221; the output string length must be ≤ than the input string length, would it give me much value?  Many assertions that are very easy to write are not worth much.</p>
<p>On the other hand, a test proves that the method works correctly in 1 concrete case.  If I choose the case well, it will give me confidence that many other similar cases work correctly.</p>
<p>You say that you use a lot of assertions in your code and find them extremely useful.  Do you write the assertions before the code?  Do you find that the usefulness comes from the insight that comes when you write them, or from the runtime checks?</p>

		</li>

	
	
		<li class="alt" id="comment-94235">
			<cite>Mario</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-94235" title="">July 4th, 2011 at 12:20</a> </small>

			<p>I totally disagree with your statement that assertions that are easy to write are not worth much. Actually, that&#8217;s the kind of statement that I would expect from someone who has never really tried to use assertions in practice. But let me try to explain in more detail why I think that, and give you some examples.</p>
<p>First of all, some quick answers: I write my assertion while I write the code, sometimes afterwards, never before. (and I do the same with tests: I find that neither gives any useful non-trivial insight in the design phase. Though I guess you would disagree here). Most of the time, if some assertion/contract is too complex, I usually don&#8217;t bother to code it (but see what I say at the end of the post). And in the case of a function like &#8220;squeeze&#8221; for example, I can&#8217;t see any contract worth enforcing, so I would just rely on a few tests there.</p>
<p>Also, many assertions that I write are not pre/postconditions, but are just embedded in the body of functions. Whenever the code I&#8217;m writing depends on some non-trivial condition, but I&#8217;m not entirely sure the surrounding code maintains it, I usually prefer to enforce it with an assertion.</p>
<p>Before writing this post I looked at some code I wrote recently that I believe can make a pretty good example, since it&#8217;s the kind of relatively complex algorithmical code that&#8217;s next to impossible for me to get right without some very serious testing. It&#8217;s the solutions to some (about 10 of them) of the puzzles posted by Facebook on their web site (see <a href="http://www.facebook.com/careers/puzzles.php" rel="nofollow">http://www.facebook.com/careers/puzzles.php</a>). I found that my code had about one assertion every 20 &#8220;real&#8221; lines of code. So it&#8217;s hardly a comprehensive coverage. Many functions/methods didn&#8217;t have any. All of them (except one) where just simple one-liners that took me at most ten seconds to write. Did they make testing redundant, or did they uncover all the bugs in the code? Surely not. Not even close to that, actually. But in practice they turned out to be very useful, allowing me to catch many bugs early and with very little effort.</p>
<p>In this particular case, would I have caught those bugs anyway eventually? I guess so, given how thoroughly I tested the code (but again, read the end of the post). Although I&#8217;m sure it would have taken both more time and more effort. But in practice not all code allows for such a complete testing in any reasonable amount of time (just to give you an example, think of a method that updates a large and complex data structure. How do you test that?). And in my experience, assertions/contracts do help find bugs that would otherwise escape testing.</p>
<p>To answer you last question, I find them useful in many ways. As you mentioned, the most important part is the runtime checks. But there are also other factors:</p>
<p>&#8211; Most of the time they pinpoint the offending lines of code. That&#8217;s something I do not get with testing alone. If a function fails a test, more often that not that doesn&#8217;t clearly show me where the error originated.</p>
<p>&#8211; When used as preconditions, they are a useful form of documentation. They remind me what conditions the parameters must satisfy.</p>
<p>&#8211; They sometimes also help me to understand better how my code works, by writing down some conditions that I expect to be true during program execution.</p>
<p>I also would like to spend a few words to defend another technique that I believe you dismissed too quickly in your post. You said that the second version of the postcondition is actually executable code, so that it could be used as an implementation. But quite apart from the fact that even in your simple case that&#8217;s not true (I believe that implementation would cause a stack overflow if the input string were long enough), that&#8217;s again missing the point. Let me use again the Facebook puzzles example. To test my code, in all cases except one, I didn&#8217;t write any standard tests. I just wrote two versions of it: I first coded a very simple brute-force solution, that wouldn&#8217;t have been usable in practice because too slow. Then I wrote the optimized algorithm, that was sometimes nearly an order of magnitude more complex. And then I randomly generated thousands of test cases, run them through both algorithms and compared the results. In the end, every piece of code I submitted passed all the Facebook tests the first time, so the technique was certainly effective in removing bugs (Facebook sources say that on average only about 10% of the submissions they receive manage to pass all their tests). And all with a reasonably small effort. Now, you can make up your own mind about whether this tecnique should be classified as a form of testing (comparison testing, as I believe it&#8217;s usually called in the literature) or as a thorough use of postconditions. But I&#8217;m pretty sure that if I had tried to debug my code using only &#8220;example testing&#8221; not only I would have had to do much more work (and very boring work at that), but I wouldn&#8217;t have got anywhere close to the same level of testing.</p>
<p>In general, while I agree that &#8220;example testing&#8221; is in many case necessary, and that you can get reasonably bug-free code with it alone if you work hard enough at it, I also believe you&#8217;ll get better result with significantly less effort if you combine it with assertions/contracts and comparison testing (and maybe other techniques).</p>

		</li>

	
	
		<li class="" id="comment-94236">
			<cite>matteo</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-94236" title="">July 4th, 2011 at 13:15</a> </small>

			<p>Hi Mario,</p>
<p>I have nothing in general against the use of assertions; I just find them less effective than TDD.  They are a different technique and I find that while assertions are very useful when coding in a non-TDD way, I don&#8217;t miss them when I do TDD.</p>
<p>That&#8217;s because when you do TDD you get to write code that&#8217;s much shorter; you have methods that rarely are longer than 10 lines.  You get to break your problem in much smaller pieces that you test and think about more thouroughly.</p>
<p>Even doing DBC would get you to much smaller pieces, as the comment by Carlo Pescio suggests (though I don&#8217;t have real experience in DBC).</p>
<p>I&#8217;m all in favor of doing plenty of testing; I think your approach of comparing two algorithms is a very good idea.  But we are comparing different things: *testing* techniques versus *design* techniques.</p>
<p>DBC and TDD are *design* techniques, not test techniques. It happens that they produce test code as a side-product, which is good; but the goal is to get to a good design, not (primarily) to ensure that the code is correct.</p>
<p>(About your remark on the recursive implementation of squeeze: sure, you could rewrite it as a tail-recursive function that does not stack-overflow, but then you&#8217;d make it less readable.  The goal in DBC is to have obviously correct specs.  The version I give is obviously correct from a mathematical point of view.)</p>

		</li>

	
	
		<li class="alt" id="comment-95000">
			<cite>Balthazar</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-95000" title="">April 2nd, 2012 at 00:34</a> </small>

			<p>I have been contemplating about getting into DbC, and searching for discussions about whether it&#8217;s really good in practice. That&#8217;s how I stumbled across this page. One reason for this is that for my latest project I started sprinkling my code with asertions all over, and it surprised me how I immediately found bugs that would have taken so much longer to track down earlier. Therefore, I started thinking about whether I should take it a step further, to write formal specifications that would act both as documentation for my suppliers, and at the same time act as early bug catchers during development.</p>
<p>I must say it seems people don&#8217;t really understand what DbC is, and your post is a great example. It&#8217;s super easy to write the contract you want. Basically, you write a function that checks whether all characters in the output string are unique. Then, you use the function as your post-condition, something like this:</p>
<p>require<br />
    input string is not null: inputString /= NULL; // Important check!!!</p>
<p>ensure<br />
    all characters are unique: allCharactersUnique( returnValue );</p>
<p>invariant<br />
    // various sanity checks that you never thought could fail here.</p>
<p>This is written in a sort of imagined DbC language that is a bit like Eiffel and a bit like C&#8230; :) The invariant is defined at class level, the pre and post conditions at method level. The precondition here is very important. It is not true, as you suggest, that all input is valid. The point is exactly that both the client and supplier behaviour is checked, as a result of your formal contracts. Your intent is clear, correctness is better ensured (but not guaranteed), and you both get to check supplier AND client behaviour. I don&#8217;t know much about test-driven development (maybe I should check it out), but in your examples given, (A) you only get to check for a specific set of inputs, (B) you only check supplier behaviour, not client behaviour. </p>
<p>The main hazard during developing may not be that your suppliers don&#8217;t work correctly, because when you write them your first time, you will probably put much thought into it. But later you may forget the details about what the class requires, your clients may use them incorrectly, or some other bug somewhere causes a function to be called with the wrong arguments, or you may make a change somewhere that you didn&#8217;t think could affect other parts of the program. This will produce incorrect results also for the kind of tests you suggest as &#8220;TDD-style tests&#8221;, but you will catch them later, and the sooner they are caught the easier they are to find. This saves much time. All these points are of course even more true in a big project with many developers. The best thing would be if, as soon as something was in an unexpected state, the debugger would stop at that line where the error happened. This may not be so easy to achieve with any development style.</p>
<p>Apart from that, I believe no matter what design principle you choose, it must be tested with a broad range of data. Each supplier must, of course be thoroughly tested on its own. If that&#8217;s what TDD means, then I suppose I agree with a previous poster, both techniques should be used together.</p>

		</li>

	
	
		<li class="" id="comment-95001">
			<cite>Balthazar</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-95001" title="">April 2nd, 2012 at 01:02</a> </small>

			<p>Oh, and one more thing: One possible reason why DbC is not widespread, is that there aren&#8217;t any good DbC-solutions for existing languages out there. DbC is part of the design process, and should preferably be an integrated part of the language. Those languages that do support it natively, are at least not very widespread. And one precondition check I forgot to put into my example which is very important: Check that your string really is a valid string. Depending on the language used, a memory-related or some other type of bug might cause the string to contain invalid characters. If the function is only intended for valid strings, it should be specified in the contract. Again, this memory-related bug might be caught by the type of tests you suggest, but it will happen at a much later time in the execution, and will be much harder to track down. Particularly if you are using a library or some supplier code that you didn&#8217;t write yourself.</p>

		</li>

	
	
		<li class="alt" id="comment-95002">
			<cite>matteo</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-95002" title="">April 2nd, 2012 at 07:02</a> </small>

			<p>Hello Balthazar,</p>
<p>indeed your post-condition is very easy to write, but it&#8217;s not a very strong postcondition.  I could implement your specification with</p>
<p>function squeeze(x)<br />
  return &#8220;abc&#8221;;<br />
end</p>
<p>and still pass your assertions.  You should add</p>
<p>ensure<br />
all input characters can be found in output: &#8230;<br />
all output characters are in the same order as in the input: &#8230;.</p>
<p>And I would find it difficult to write those assertions in a way that is super-clear what they mean.</p>
<p>I mean, your assertion is certainly a useful check.  It&#8217;s not a sufficient check; you would need to test your code on several examples.  And your assertion does not drive you toward a solution.  As Carlo says above (please read his comment carefully, as he has some useful and non-obvious things to say), if it does not help you find the shape of your code, then it&#8217;s not a design method.  </p>
<p>If all you do is check simple properties of your output then what you have is a tool for protecting you from errors, not a design tool.  Valuable, yes, but I would still want something else for a design tool.</p>
<p>Matteo</p>

		</li>

	
	
		<li class="" id="comment-95003">
			<cite>Balthazar</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-95003" title="">April 2nd, 2012 at 11:10</a> </small>

			<p>Yes, I know. I was focusing on the precondition part because that&#8217;s where your more obvious lack of understanding for what DbC meant where to be found. </p>
<p>I could pass your own test, like this:<br />
function squeeze(x)<br />
    if x equals &#8220;&#8221; then return &#8220;&#8221;<br />
    if x equals &#8220;aaabbccccaa&#8221; then return &#8220;abca&#8221;<br />
end</p>
<p>Also, it seemed you didn&#8217;t understand that the check could be implemnted as functions or class methods. Regarding your two additional checks, I might write each of them too as functions. Then the function name, plus the description, which is part of the contract, would be very self explanatory in my view. It seems to me as you are confusing Can&#8217;t Solve All The Problems In The World for unusable. DbC can&#8217;t solve all the problems in the world, and you may need to write some additional specs (like you would in your TDD examples) but, not having tried it out, I believe it can be a good help in structuring your code.</p>
<p>Of course, I would need to test my code with several examples. DbC is not meant to be a substitute for testing, rather and aid to it. When you write &#8220;And your assertion does not drive you toward a solution. As Carlo says above (please read his comment carefully, as he has some useful and non-obvious things to say), if it does not help you find the shape of your code, then it’s not a design method&#8221;. I couldn&#8217;t disagree more!! It most certainly does help my designing of the program. By clarifying my contracts, I am lying out the structure of the program in terms of obligations and benefits between each different part of the program, so, it could be a huge help in defining the overall structure of the program. How to the parts play TOGETHER, that&#8217;s what DbC seems to focus on, not how should each feature be IMPLEMENTED. You seem to be focusing on implementation, not on interplay/communication between different parts of the software. The principle here is that we see each class, method, function whatever as either a supplier or a client, and in most cases I guess both, and the contracts help define the relationships and rules between them. Implementation solutions and software design are not the same thing. And manually parsing a long list of test cases like the one you suggest in your post doesn&#8217;t seem like a good help in figuring out how the main structure of the software works, or how to use or extend a class. On the other hand, preconditions seem like a stronger part of the DbC design paradigm than postconditions. That&#8217;s meaybe the reason why I focus on the pres and you focus on the posts.</p>
<p>I have tried, instead of reading Carlo&#8217;s post (which I will read later), to get a bit more educated on TDD. So far, it seems extremely tedious and unusable for my case. In my case I am working on a piece of software that requires a lot of concurrency and lock free data structures, because it is a realtime app. It also requires a VERY complex GUI, which is what I am currently working on. I have been thinking about how I should write the test cases for the GUI, and have problems figuring out how. I would have to write some sort of simulator, that simulates each mouseclick, mousedragged or mousemoved action, plus combinations with modifier keys, which would be perhaps thousands of events during a user session, and don&#8217;t forget that there are million trillion gazzillion possible combinations of those&#8230; I thought of writing an event recorder, which would be a very different approach from the TDD process anyway, but that wouldn&#8217;t help me much. Soon as I change some sizes and values in my code, the &#8220;test cases&#8221; would be invalidated, because graphical elements (in this case cells in a tree-like matrix) would get laid out differently on the screen. So I believe I would have to write some sort of test cases manually (HUGE JOB) that were tightly integrated with the implementation of my graphical layout system, and then it turns out writing and maintaining the test cases could get much harder and time consuming than writing the actual code. Sure I could end up with something useful, but if I have then overlooked some user interaction sequence, and invoke that sequence during live testing, the already written test cases would not help me catching the bug.</p>
<p>That&#8217;s where I thought DbC might come handy. DbC focuses not only on how the suppliers behave under a constrained set of data, but on how the pieces play TOGETHER. So, if I invoke a new bug in my program during live testing, the error will be caught at a much earlier time. Of course this could be easily combined with an event recorder which helps me reproduce the error. This focus on how the parts play together is what we all rely on, actually, when we start using a new library. Your test cases can&#8217;t help ensure that you use your libraries right, but assertions in (most of) these libraries help ensure this to some degree, at least. And this functionality is in fact a very basic application of DbC design. But, if you really are able to predict all possible user interactions, and really stick to the TDD mantras in a die-hard way, I agree that TDD seem to be a far more bulletproof way of ensuring bug free code than DbC.</p>

		</li>

	
	
		<li class="alt" id="comment-95005">
			<cite>Balthazar</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-95005" title="">April 3rd, 2012 at 15:39</a> </small>

			<p>Update: I have been reading a bit more about TDD, and thought about the big obstacles to employing DbC to a project. The biggest obstacle to DbC is that there is no native language support for the c family of languages. This makes the benefits diminish. In addition, there are the many difficulties associated with writing posconditions. Say you have an hash table, writing a postcondition for the set function would be easy, but writing a postcondition for the get function much harder. But then again, in many cases DbC could be great. Say you had a layout system which could enforce right margin alignment to text, like what you have in the comments section on this page. In that case, writing the postcondition as a function that checks that each word is correctly aligned wouldn&#8217;t be hard. A class invariant could check whether the distance between each word on a line is always equal, which would work equally well for right alignment and block alignment.</p>
<p>Anyway, because of the drawbacks to DbC, and after reading many posters being happy with TDD, I have decided I&#8217;ll try to adopt TDD instead as a start. The two systems are clearly not mutually exclusive, but TDD is available right out-of-the-box in my development API&#8217;s/IDE. Since my application is largely GUI-centric, there are parts of it that can&#8217;t be developed that way, but looking at my codebase, that is currently just a rather thin view layer that would need to be tested by a human. It is already fairly modular and decoupled as TDD-ers recommend. Also, my application requires much lock free concurrency, and needs to host third-party plug-ins, so I believe there&#8217;s no way I can get around live testing. DbC would be a great add-on for this, in addition to TDD, but it&#8217;s just not available. (at least *real* DbC).</p>

		</li>

	
	
		<li class="" id="comment-95006">
			<cite>matteo</cite> Says:
						<br />

			<small class="commentmetadata"><a href="#comment-95006" title="">April 3rd, 2012 at 18:12</a> </small>

			<p>Balthazar,</p>
<blockquote><p>
Yes, I know. I was focusing on the precondition part because that’s where your more obvious lack of understanding for what DbC meant where to be found.</p>
<p>I could pass your own test, like this:<br />
function squeeze(x)<br />
if x equals “” then return “”<br />
if x equals “aaabbccccaa” then return “abca”<br />
end
</p></blockquote>
<p>The precondition is obvious and uninteresting for the point I want to make in this article.</p>
<p>Consider that the simple TDD test proves that the implementation works correctly in <em>at least one case</em>.  This is a crucial point; your weak postcondition does not even do that.  It does not matter that I can easily &#8220;fool&#8221; the TDD tests by answering exactly the cases that are being tested.  When I do TDD, I write the tests to support my coding.  TDD tests are whitebox tests, not blackbox tests.</p>

		</li>

	
	
	</ol>

 


<h3 id="respond">Leave a Reply</h3>


<form action="http://matteo.vaccari.name/blog/wp-comments-post.php" method="post" id="commentform">


<p><input type="text" name="author" id="author" value="" size="22" tabindex="1" />
<label for="author"><small>Name (required)</small></label></p>

<p><input type="text" name="email" id="email" value="" size="22" tabindex="2" />
<label for="email"><small>Mail (will not be published) (required)</small></label></p>

<p><input type="text" name="url" id="url" value="" size="22" tabindex="3" />
<label for="url"><small>Website</small></label></p>


<!--<p><small><strong>XHTML:</strong> You can use these tags: &lt;a href=&quot;&quot; title=&quot;&quot;&gt; &lt;abbr title=&quot;&quot;&gt; &lt;acronym title=&quot;&quot;&gt; &lt;b&gt; &lt;blockquote cite=&quot;&quot;&gt; &lt;cite&gt; &lt;code&gt; &lt;del datetime=&quot;&quot;&gt; &lt;em&gt; &lt;i&gt; &lt;q cite=&quot;&quot;&gt; &lt;s&gt; &lt;strike&gt; &lt;strong&gt; </small></p>-->

<p><textarea name="comment" id="comment" cols="100%" rows="10" tabindex="4"></textarea></p>

<p><input name="submit" type="submit" id="submit" tabindex="5" value="Submit Comment" />
<input type="hidden" name="comment_post_ID" value="602" />
</p>
<p style="display: none;"><input type="hidden" id="akismet_comment_nonce" name="akismet_comment_nonce" value="f91cd75ee4" /></p><p style="display: none;"><input type="hidden" id="ak_js" name="ak_js" value="146"/></p>
</form>



	
    </div>

    <div id='right-col'>
        <div id="sidebar">
    <ul>

      <li>
        <form method="get" id="searchform" action="http://matteo.vaccari.name/blog/">
  <div>
    <input tabindex="1" type="text" value="" name="s" id="s" />
    <input type="submit" id="searchsubmit" value="Search" />
  </div>
</form>
      </li>

      <li>

        <h2>About</h2>

	I am a software developer working with <a href="http://thoughtworks.com/">Thoughtworks Italia</a>.
        I'm a fan of <a
        href="http://extremeprogramming.org/">Extreme Programming</a>.
        I&nbsp;helped organize the <a
        href="http://essap.dicom.uninsubria.it/">European Summer School on
        Agile Programming</a>

      </li>

      <li>
            </li>

      <li class="pagenav"><h2>Pages</h2><ul><li class="page_item page-item-851"><a href="../selected-tdd-resources-to-start.html">Selected TDD Resources To Start</a></li>
<li class="page_item page-item-583"><a href="../tdd-resources.html">TDD Resources</a></li>
<li class="page_item page-item-247"><a href="../the-hexagonal-architecture.html">The Hexagonal Architecture</a></li>
</ul></li>

      
      <li><h2>Archives</h2>
        <ul>
        	<li><a href='date/2018/10.html'>October 2018</a></li>
	<li><a href='date/2017/09.html'>September 2017</a></li>
	<li><a href='date/2016/08.html'>August 2016</a></li>
	<li><a href='date/2016/03.html'>March 2016</a></li>
	<li><a href='date/2016/01.html'>January 2016</a></li>
	<li><a href='date/2014/12.html'>December 2014</a></li>
	<li><a href='date/2014/10.html'>October 2014</a></li>
	<li><a href='date/2014/06.html'>June 2014</a></li>
	<li><a href='date/2014/02.html'>February 2014</a></li>
	<li><a href='date/2013/12.html'>December 2013</a></li>
	<li><a href='date/2013/11.html'>November 2013</a></li>
	<li><a href='date/2013/06.html'>June 2013</a></li>
	<li><a href='date/2013/05.html'>May 2013</a></li>
	<li><a href='date/2013/03.html'>March 2013</a></li>
	<li><a href='date/2013/02.html'>February 2013</a></li>
	<li><a href='date/2012/10.html'>October 2012</a></li>
	<li><a href='date/2012/08.html'>August 2012</a></li>
	<li><a href='date/2012/07.html'>July 2012</a></li>
	<li><a href='date/2012/06.html'>June 2012</a></li>
	<li><a href='date/2012/05.html'>May 2012</a></li>
	<li><a href='date/2012/04.html'>April 2012</a></li>
	<li><a href='date/2012/01.html'>January 2012</a></li>
	<li><a href='date/2011/12.html'>December 2011</a></li>
	<li><a href='date/2011/11.html'>November 2011</a></li>
	<li><a href='date/2011/10.html'>October 2011</a></li>
	<li><a href='date/2011/07.html'>July 2011</a></li>
	<li><a href='date/2011/06.html'>June 2011</a></li>
	<li><a href='date/2011/05.html'>May 2011</a></li>
	<li><a href='date/2011/04.html'>April 2011</a></li>
	<li><a href='date/2011/03.html'>March 2011</a></li>
	<li><a href='date/2011/02.html'>February 2011</a></li>
	<li><a href='date/2010/11.html'>November 2010</a></li>
	<li><a href='date/2010/10.html'>October 2010</a></li>
	<li><a href='date/2010/09.html'>September 2010</a></li>
	<li><a href='date/2010/08.html'>August 2010</a></li>
	<li><a href='date/2010/07.html'>July 2010</a></li>
	<li><a href='date/2010/06.html'>June 2010</a></li>
	<li><a href='date/2010/05.html'>May 2010</a></li>
	<li><a href='date/2010/04.html'>April 2010</a></li>
	<li><a href='date/2010/03.html'>March 2010</a></li>
	<li><a href='date/2010/02.html'>February 2010</a></li>
	<li><a href='date/2010/01.html'>January 2010</a></li>
	<li><a href='date/2009/12.html'>December 2009</a></li>
	<li><a href='date/2009/11.html'>November 2009</a></li>
	<li><a href='date/2009/10.html'>October 2009</a></li>
	<li><a href='date/2009/09.html'>September 2009</a></li>
	<li><a href='date/2009/07.html'>July 2009</a></li>
	<li><a href='date/2009/05.html'>May 2009</a></li>
	<li><a href='date/2009/04.html'>April 2009</a></li>
	<li><a href='date/2009/03.html'>March 2009</a></li>
	<li><a href='date/2009/02.html'>February 2009</a></li>
	<li><a href='date/2009/01.html'>January 2009</a></li>
	<li><a href='date/2008/12.html'>December 2008</a></li>
	<li><a href='date/2008/11.html'>November 2008</a></li>
	<li><a href='date/2008/10.html'>October 2008</a></li>
	<li><a href='date/2008/09.html'>September 2008</a></li>
	<li><a href='date/2008/07.html'>July 2008</a></li>
	<li><a href='date/2008/06.html'>June 2008</a></li>
	<li><a href='date/2008/05.html'>May 2008</a></li>
	<li><a href='date/2008/04.html'>April 2008</a></li>
	<li><a href='date/2008/01.html'>January 2008</a></li>
	<li><a href='date/2007/11.html'>November 2007</a></li>
	<li><a href='date/2007/10.html'>October 2007</a></li>
	<li><a href='date/2007/09.html'>September 2007</a></li>
	<li><a href='date/2007/06.html'>June 2007</a></li>
	<li><a href='date/2007/05.html'>May 2007</a></li>
	<li><a href='date/2007/04.html'>April 2007</a></li>
	<li><a href='date/2007/03.html'>March 2007</a></li>
	<li><a href='date/2007/02.html'>February 2007</a></li>
	<li><a href='date/2007/01.html'>January 2007</a></li>
	<li><a href='date/2006/12.html'>December 2006</a></li>
	<li><a href='date/2006/11.html'>November 2006</a></li>
	<li><a href='date/2006/10.html'>October 2006</a></li>
	<li><a href='date/2006/09.html'>September 2006</a></li>
	<li><a href='date/2006/08.html'>August 2006</a></li>
	<li><a href='date/2006/07.html'>July 2006</a></li>
	<li><a href='date/2006/06.html'>June 2006</a></li>
	<li><a href='date/2006/05.html'>May 2006</a></li>
	<li><a href='date/2006/04.html'>April 2006</a></li>
	<li><a href='date/2006/03.html'>March 2006</a></li>
	<li><a href='date/2006/02.html'>February 2006</a></li>
	<li><a href='date/2006/01.html'>January 2006</a></li>
        </ul>
      </li>

      <li><h2>Categories</h2>
        <ul>
        	<li class="cat-item cat-item-1"><a href="category/agile.html" >Agile</a> (229)
</li>
	<li class="cat-item cat-item-3"><a href="category/books.html" >Books</a> (2)
</li>
	<li class="cat-item cat-item-11"><a href="category/design-exercise.html" >Design Exercise</a> (5)
</li>
	<li class="cat-item cat-item-6"><a href="category/essay.html" >Essay</a> (13)
</li>
	<li class="cat-item cat-item-8"><a href="category/expressive-code.html" >Expressive Code</a> (11)
</li>
	<li class="cat-item cat-item-10"><a href="category/fundamentals.html" >Fundamentals</a> (6)
</li>
	<li class="cat-item cat-item-9"><a href="category/other.html" >other</a> (1)
</li>
        </ul>
      </li>

      
    </ul>
  </div>

    </div>
</div>


<hr />
<div id="footer">
<address>
  <script type="text/javascript">eval(unescape('%64%6f%63%75%6d%65%6e%74%2e%77%72%69%74%65%28%27%3c%61%20%68%72%65%66%3d%22%6d%61%69%6c%74%6f%3a%76%61%63%63%61%72%69%40%70%6f%62%6f%78%2e%63%6f%6d%22%3e%76%61%63%63%61%72%69%40%70%6f%62%6f%78%2e%63%6f%6d%3c%2f%61%3e%27%29%3b'))</script>
</address>
</div>
</div>
  <script type='text/javascript' src='../wp-includes/js/wp-embed.min3c21.js?ver=5.1.1'></script>
<script async="async" type='text/javascript' src='../wp-content/plugins/akismet/_inc/form0235.js?ver=4.1.1'></script>
</body>

<!-- Mirrored from matteo.vaccari.name/blog/archives/602 by HTTrack Website Copier/3.x [XR&CO'2014], Fri, 24 Sep 2021 10:24:45 GMT -->
</html>
