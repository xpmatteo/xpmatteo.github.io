<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: Greed and Simple Design	</title>
	<atom:link href="http://matteo.vaccari.name/blog/archives/709/feed" rel="self" type="application/rss+xml" />
	<link>http://matteo.vaccari.name/blog/archives/709</link>
	<description>Extreme enthusiasm</description>
	<lastBuildDate>
	Mon, 25 Feb 2019 15:18:16 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.1.1</generator>
			<item>
				<title>
				By: David Semeria				</title>
				<link>http://matteo.vaccari.name/blog/archives/709/comment-page-1#comment-94973</link>
		<dc:creator><![CDATA[David Semeria]]></dc:creator>
		<pubDate>Wed, 22 Feb 2012 22:15:41 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=709#comment-94973</guid>
					<description><![CDATA[Good code, like good art, should beautiful and simple and pure.]]></description>
		<content:encoded><![CDATA[<p>Good code, like good art, should beautiful and simple and pure.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Carlo Pescio				</title>
				<link>http://matteo.vaccari.name/blog/archives/709/comment-page-1#comment-94845</link>
		<dc:creator><![CDATA[Carlo Pescio]]></dc:creator>
		<pubDate>Sun, 22 Jan 2012 17:38:18 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=709#comment-94845</guid>
					<description><![CDATA[I won&#039;t go into a word-by-word dissection of what we said :-), in the end you&#039;re choosing to read the 4 principles favorably, I don&#039;t, therefore we come to different conclusions. That&#039;s one of the many issues with a discipline stuck on &quot;principles&quot; (I have a long-due, half-baked post about this, waiting to be finished, someday). 
For instance, you say &quot;This is why it is not true that a single, monolithig procedure would score “simpler”&quot;. I say that it would according to principle 4, and  that principle #3 is too fluffy to offer true guidance for those who need it. We could argue forever, and yet the discipline itself would make little or no progress.

About the code. The problem with small-scale &quot;code katas&quot; (or even worse, small-scale code katas within the context of a specific language), is that we easily slip into the mindset of solving the problem through clever usage of language features, like map-reduce. In this sense, I&#039;m relatively skeptical about their contribution when your goal is to explore the design space.

Still, you probably remember that I solved a similar problem (yahtzee, http://www.carlopescio.com/2011/06/cut-red-wire.html), explaining my reasoning while writing code. I would probably point people in that direction (including the &quot;limits and confessions&quot; at the end). 
But again, design is way more than that. It&#039;s about understanding forces, materials, choices, consequences, recognizing familiar structures, exploring different venues for the fun of it, etc etc. Constraining all that within a few principles is terribly sad :-)).

Curiously enough, though we tend to disagree on many things here and there, your final suggestion (&quot;Make your code look like a model of the problem!&quot;) is very much aligned with the DSL approach I took for yahtzee. Again, I see this agreement/disagreement mostly as the inability of contemporary design narrative to faithfully represent our (largely shared) sensibility for &quot;good design&quot;.]]></description>
		<content:encoded><![CDATA[<p>I won&#8217;t go into a word-by-word dissection of what we said :-), in the end you&#8217;re choosing to read the 4 principles favorably, I don&#8217;t, therefore we come to different conclusions. That&#8217;s one of the many issues with a discipline stuck on &#8220;principles&#8221; (I have a long-due, half-baked post about this, waiting to be finished, someday).<br />
For instance, you say &#8220;This is why it is not true that a single, monolithig procedure would score “simpler”&#8221;. I say that it would according to principle 4, and  that principle #3 is too fluffy to offer true guidance for those who need it. We could argue forever, and yet the discipline itself would make little or no progress.</p>
<p>About the code. The problem with small-scale &#8220;code katas&#8221; (or even worse, small-scale code katas within the context of a specific language), is that we easily slip into the mindset of solving the problem through clever usage of language features, like map-reduce. In this sense, I&#8217;m relatively skeptical about their contribution when your goal is to explore the design space.</p>
<p>Still, you probably remember that I solved a similar problem (yahtzee, <a href="http://www.carlopescio.com/2011/06/cut-red-wire.html" rel="nofollow">http://www.carlopescio.com/2011/06/cut-red-wire.html</a>), explaining my reasoning while writing code. I would probably point people in that direction (including the &#8220;limits and confessions&#8221; at the end).<br />
But again, design is way more than that. It&#8217;s about understanding forces, materials, choices, consequences, recognizing familiar structures, exploring different venues for the fun of it, etc etc. Constraining all that within a few principles is terribly sad :-)).</p>
<p>Curiously enough, though we tend to disagree on many things here and there, your final suggestion (&#8220;Make your code look like a model of the problem!&#8221;) is very much aligned with the DSL approach I took for yahtzee. Again, I see this agreement/disagreement mostly as the inability of contemporary design narrative to faithfully represent our (largely shared) sensibility for &#8220;good design&#8221;.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: matteo				</title>
				<link>http://matteo.vaccari.name/blog/archives/709/comment-page-1#comment-94844</link>
		<dc:creator><![CDATA[matteo]]></dc:creator>
		<pubDate>Sun, 22 Jan 2012 14:43:21 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=709#comment-94844</guid>
					<description><![CDATA[@Giorgio: (re)read what Ron Jeffries has to say about this:

&lt;a href=&quot;http://groups.google.com/group/software_craftsmanship/msg/84106f8a09a9486c&quot; rel=&quot;nofollow&quot;&gt;http://groups.google.com/group/software_craftsmanship/msg/84106f8a09a9486c&lt;/a&gt;]]></description>
		<content:encoded><![CDATA[<p>@Giorgio: (re)read what Ron Jeffries has to say about this:</p>
<p><a href="http://groups.google.com/group/software_craftsmanship/msg/84106f8a09a9486c" rel="nofollow">http://groups.google.com/group/software_craftsmanship/msg/84106f8a09a9486c</a></p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: matteo				</title>
				<link>http://matteo.vaccari.name/blog/archives/709/comment-page-1#comment-94843</link>
		<dc:creator><![CDATA[matteo]]></dc:creator>
		<pubDate>Sun, 22 Jan 2012 14:37:37 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=709#comment-94843</guid>
					<description><![CDATA[
Hi Carlo, thanks for biting.  I agree that simplicity is not an end in itself; but in the context of Extreme Programming, is the enabling factor that makes it possible for Extreme Programming to make sense :-)  Once you have simplicity, you are in a good position to obtain your other goals, whatever they are.  I must address some of your comments below:

&lt;blockquote&gt;
#1 can be trivially satisfied by writing few or no tests :-)
&lt;/blockquote&gt;

These 4 elements are meant as a compass for people doing Extreme Programming.  In this context you don&#039;t even have to mention &quot;no tests&quot;.  In general, the real meaning of this first rule is that &quot;working code is worth more than non-working code, no matter how beautifully designed.&quot;  Working code driven by test is base one.  Almost everyone learning XP is able to get to this stage.  The difficul bit lies in satisfying the later rules :-)

&lt;blockquote&gt;
#2 is not a measure of simplicity, per se. We usually remove duplication by abstraction. Some people find abstract code harder to read (I normally don’t, but I’ve met many).
&lt;/blockquote&gt;

I disagree.  &lt;a href=&quot;http://www.fcgarage.com/2009/05/the-magic-suitcase.html&quot; title=&quot;The Magic Suitcase - FC Garage by Francesco Cirillo&quot; rel=&quot;nofollow&quot;&gt;Simple is not easy&lt;/a&gt;.  Finding the right way to remove duplication is not always easy, and it&#039;s not easy because there might be more than one way, and some ways are worse than others.  It may happen that you in removing duplication we add complexity; this usually means that we have not found the right abstractions, or that we have not finished removing duplication.

&lt;blockquote&gt;
#3 is too fluffy, which is unfortunate (see below).

#4 is stacking the cards against structural complexity (while still ignoring coupling altogether) but says nothing against procedural complexity. So, a single long method with no duplication and a huge switch/case inside would score as “simpler” than a number of small classes with short methods.

To be fair, the compensating force for #4 is #3, as “expressing ideas” should push you to introduce concepts, through classes and methods. Unfortunately, #4 is easy to grasp and calculate, #3 is ambiguous and fluffy, so they don’t really balance out.
&lt;/blockquote&gt;

It is true that #3 cannot be measured as easily as the other rules.  So be it.  Nobody promised that we could find the best design by a mechanical search in the space of possible solutions.  We have to think; we have to decide what ideas we want to express.  This is why it is not true that a single, monolithig procedure would score &quot;simpler&quot;.  Rule #4 is a warning against letting our ego run free with unnecessary abstraction or generality.

&lt;blockquote&gt;
 That’s particularly bad for people in early stages of skill acquisition, who lack the maturity to understand nuanced concepts.
&lt;/blockquote&gt;

True.  I&#039;m beginning think that the unspoken assumptions behind XP was that everyone had the design and coding skills of Ward Cunningham.  Kent Beck wrote plenty about how to code effectively in SmallTalk, but wrote very little (in comparison) on how to code effectively in XP.

I find that reasoning about and practicing the consequences of these 4 rules is an essential step towards becoming proficient at TDD.  

But Carlo, since you say that design is way more than these four rules, what would *you* say about the solutions such as the one above, and the many other that can be found on Stackoverflow?  What would you say to these students from the perspective of your knowledge of design?
]]></description>
		<content:encoded><![CDATA[<p>Hi Carlo, thanks for biting.  I agree that simplicity is not an end in itself; but in the context of Extreme Programming, is the enabling factor that makes it possible for Extreme Programming to make sense :-)  Once you have simplicity, you are in a good position to obtain your other goals, whatever they are.  I must address some of your comments below:</p>
<blockquote><p>
#1 can be trivially satisfied by writing few or no tests :-)
</p></blockquote>
<p>These 4 elements are meant as a compass for people doing Extreme Programming.  In this context you don&#8217;t even have to mention &#8220;no tests&#8221;.  In general, the real meaning of this first rule is that &#8220;working code is worth more than non-working code, no matter how beautifully designed.&#8221;  Working code driven by test is base one.  Almost everyone learning XP is able to get to this stage.  The difficul bit lies in satisfying the later rules :-)</p>
<blockquote><p>
#2 is not a measure of simplicity, per se. We usually remove duplication by abstraction. Some people find abstract code harder to read (I normally don’t, but I’ve met many).
</p></blockquote>
<p>I disagree.  <a href="http://www.fcgarage.com/2009/05/the-magic-suitcase.html" title="The Magic Suitcase - FC Garage by Francesco Cirillo" rel="nofollow">Simple is not easy</a>.  Finding the right way to remove duplication is not always easy, and it&#8217;s not easy because there might be more than one way, and some ways are worse than others.  It may happen that you in removing duplication we add complexity; this usually means that we have not found the right abstractions, or that we have not finished removing duplication.</p>
<blockquote><p>
#3 is too fluffy, which is unfortunate (see below).</p>
<p>#4 is stacking the cards against structural complexity (while still ignoring coupling altogether) but says nothing against procedural complexity. So, a single long method with no duplication and a huge switch/case inside would score as “simpler” than a number of small classes with short methods.</p>
<p>To be fair, the compensating force for #4 is #3, as “expressing ideas” should push you to introduce concepts, through classes and methods. Unfortunately, #4 is easy to grasp and calculate, #3 is ambiguous and fluffy, so they don’t really balance out.
</p></blockquote>
<p>It is true that #3 cannot be measured as easily as the other rules.  So be it.  Nobody promised that we could find the best design by a mechanical search in the space of possible solutions.  We have to think; we have to decide what ideas we want to express.  This is why it is not true that a single, monolithig procedure would score &#8220;simpler&#8221;.  Rule #4 is a warning against letting our ego run free with unnecessary abstraction or generality.</p>
<blockquote><p>
 That’s particularly bad for people in early stages of skill acquisition, who lack the maturity to understand nuanced concepts.
</p></blockquote>
<p>True.  I&#8217;m beginning think that the unspoken assumptions behind XP was that everyone had the design and coding skills of Ward Cunningham.  Kent Beck wrote plenty about how to code effectively in SmallTalk, but wrote very little (in comparison) on how to code effectively in XP.</p>
<p>I find that reasoning about and practicing the consequences of these 4 rules is an essential step towards becoming proficient at TDD.  </p>
<p>But Carlo, since you say that design is way more than these four rules, what would *you* say about the solutions such as the one above, and the many other that can be found on Stackoverflow?  What would you say to these students from the perspective of your knowledge of design?</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Carlo Pescio				</title>
				<link>http://matteo.vaccari.name/blog/archives/709/comment-page-1#comment-94840</link>
		<dc:creator><![CDATA[Carlo Pescio]]></dc:creator>
		<pubDate>Sat, 21 Jan 2012 17:30:34 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=709#comment-94840</guid>
					<description><![CDATA[Although I said something slightly different, I&#039;ll bite your bait :-). 

Simplicity is one of the many informal-yet-useful properties of a good design. It&#039;s just not enough to declare a design &quot;good&quot;.

Honestly, even as far as simplicity is concerned, I find the 4 principles lacking.

#1 can be trivially satisfied by writing few or no tests :-)

#2 is not a measure of simplicity, per se. We usually remove duplication by abstraction. Some people find abstract code harder to read (I normally don&#039;t, but I&#039;ve met many).

#3 is too fluffy, which is unfortunate (see below)

#4 is stacking the cards against structural complexity (while still ignoring coupling altogether) but says nothing against procedural complexity. So, a single long method with no duplication and a huge switch/case inside would score as &quot;simpler&quot; than a number of small classes with short methods.

To be fair, the compensating force for #4 is #3, as &quot;expressing ideas&quot; should push you to introduce concepts, through classes and methods. Unfortunately, #4 is easy to grasp and calculate, #3 is ambiguous and fluffy, so they don&#039;t really balance out. That&#039;s particularly bad for people in early stages of skill acquisition, who lack the maturity to understand nuanced concepts.

Overall, the entire set of principles is heavily biased toward design-as-code, henceforth preventing any useful design conversation at larger scale. This is something I discussed in an older post (http://www.carlopescio.com/2011/02/is-software-design-literature-dead.html)

Useful compass? Perhaps. Still, design is way more than that :-)]]></description>
		<content:encoded><![CDATA[<p>Although I said something slightly different, I&#8217;ll bite your bait :-). </p>
<p>Simplicity is one of the many informal-yet-useful properties of a good design. It&#8217;s just not enough to declare a design &#8220;good&#8221;.</p>
<p>Honestly, even as far as simplicity is concerned, I find the 4 principles lacking.</p>
<p>#1 can be trivially satisfied by writing few or no tests :-)</p>
<p>#2 is not a measure of simplicity, per se. We usually remove duplication by abstraction. Some people find abstract code harder to read (I normally don&#8217;t, but I&#8217;ve met many).</p>
<p>#3 is too fluffy, which is unfortunate (see below)</p>
<p>#4 is stacking the cards against structural complexity (while still ignoring coupling altogether) but says nothing against procedural complexity. So, a single long method with no duplication and a huge switch/case inside would score as &#8220;simpler&#8221; than a number of small classes with short methods.</p>
<p>To be fair, the compensating force for #4 is #3, as &#8220;expressing ideas&#8221; should push you to introduce concepts, through classes and methods. Unfortunately, #4 is easy to grasp and calculate, #3 is ambiguous and fluffy, so they don&#8217;t really balance out. That&#8217;s particularly bad for people in early stages of skill acquisition, who lack the maturity to understand nuanced concepts.</p>
<p>Overall, the entire set of principles is heavily biased toward design-as-code, henceforth preventing any useful design conversation at larger scale. This is something I discussed in an older post (<a href="http://www.carlopescio.com/2011/02/is-software-design-literature-dead.html" rel="nofollow">http://www.carlopescio.com/2011/02/is-software-design-literature-dead.html</a>)</p>
<p>Useful compass? Perhaps. Still, design is way more than that :-)</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Giorgio Sironi				</title>
				<link>http://matteo.vaccari.name/blog/archives/709/comment-page-1#comment-94839</link>
		<dc:creator><![CDATA[Giorgio Sironi]]></dc:creator>
		<pubDate>Sat, 21 Jan 2012 16:21:42 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=709#comment-94839</guid>
					<description><![CDATA[I usually invert the rule 2 and 3 to get tests-expression-no_duplication-minimal:
http://c2.com/cgi/wiki?XpSimplicityRules
while assuming there is a decreasing order of importance from rule 1 to 4.
In fact, if there is such an order, your code wins over the idiomatic Ruby example because it favors expressiveness over elimination of duplication (exhaustive list of rules) and minimality (four methods instead of one).]]></description>
		<content:encoded><![CDATA[<p>I usually invert the rule 2 and 3 to get tests-expression-no_duplication-minimal:<br />
<a href="http://c2.com/cgi/wiki?XpSimplicityRules" rel="nofollow">http://c2.com/cgi/wiki?XpSimplicityRules</a><br />
while assuming there is a decreasing order of importance from rule 1 to 4.<br />
In fact, if there is such an order, your code wins over the idiomatic Ruby example because it favors expressiveness over elimination of duplication (exhaustive list of rules) and minimality (four methods instead of one).</p>
]]></content:encoded>
						</item>
			</channel>
</rss>
