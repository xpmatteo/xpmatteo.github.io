<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	
	>
<channel>
	<title>
	Comments on: Framework-free web programming	</title>
	<atom:link href="http://matteo.vaccari.name/blog/archives/478/feed" rel="self" type="application/rss+xml" />
	<link>http://matteo.vaccari.name/blog/archives/478</link>
	<description>Extreme enthusiasm</description>
	<lastBuildDate>
	Mon, 25 Feb 2019 15:18:16 +0000	</lastBuildDate>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.1.1</generator>
			<item>
				<title>
				By: Gian Marco Gherardi				</title>
				<link>http://matteo.vaccari.name/blog/archives/478/comment-page-1#comment-93620</link>
		<dc:creator><![CDATA[Gian Marco Gherardi]]></dc:creator>
		<pubDate>Mon, 15 Nov 2010 09:53:44 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=478#comment-93620</guid>
					<description><![CDATA[Grazie per aver dedicato tempo ad una risposta così articolata.

&quot;...parti dal preconcetto di avere bisogno di un framework per fare mapping object-relational.&quot;
Se come storage usi un RDBMS e vuoi programmare ad oggetti, puoi essere certo che dovrai risolvere problemi di &quot;Impedance Mismatch&quot;. Sono problemi noti da anni come gli approcci per risolverli. A questo punto si puo decidere di risolverseli a mano oppure di utilizzare un framework. La scelta dipende dagli skill del team e dal grado di complessità dell&#039;object model e del db. Promuovere l&#039;idea che un framework non sia necessario è azzardato quanto promuovere l&#039;idea che sia necessario.

“abbiamo bisogno di un MVC”
Concordo che sia una assunzione sbagliata. Il processo magari potrebbe essere &quot;dobbiamo garantire una certa qualità&quot; =&#062; &quot;il PATTERN MVC è un buon approccio&quot;. La scelta della implementazione di MVC da usare è quindi una mera scelta di quale implementazione ci torna piu comoda e va fatta in base agli skill del team e alle peculiarità della applicazione. Promuovere l&#039;idea che un framework non sia necessario è azzardato quanto promuovere l&#039;idea che sia necessario.

&quot;i problemi tecnologici che si incontrano in una normale applicazione di tipo gestionale si risolvono bene in maniera incrementale, senza bisogno di framework&quot;.
Se hai a disposizione un team MOLTO bravo, quello che succede è che, all&#039;aumentare della complessità del progetto, in maniera incremtale emerga un framework. Ruby on Rails insegna. Se invece il team è SOLO normale, probabilmente all&#039;aumentare della complessità ti troverai con un mix tra codice applicativo e codice di framework. Dipende dalla qualità del team.

&quot;Il codice scritto con i framework non è più semplice di quello scritto senza framework&quot;
Per uno che conosce il DSL di Spring, è molto piu facile capire lo scope di un servizio di quanto non lo sia cercando tutti i &quot;new&quot; sparsi nel codice. Dipende dagli skill del team.

Le scelte tecnologice vengono operate in genere all&#039;inizio di un progetto, fase in cui si hanno a disposizione ben pochi elementi per &quot;indovinare&quot;. Proprio per questo, promuovere l&#039;idea che un framework non sia necessario è azzardato quanto promuovere l&#039;idea che sia necessario. La cosa migliore in questa incertezza è scegliere la strada in cui il team si sente piu sicuro. E potrebbe essere quella di adottare un Framework oppure no, il punto non è quello.]]></description>
		<content:encoded><![CDATA[<p>Grazie per aver dedicato tempo ad una risposta così articolata.</p>
<p>&#8220;&#8230;parti dal preconcetto di avere bisogno di un framework per fare mapping object-relational.&#8221;<br />
Se come storage usi un RDBMS e vuoi programmare ad oggetti, puoi essere certo che dovrai risolvere problemi di &#8220;Impedance Mismatch&#8221;. Sono problemi noti da anni come gli approcci per risolverli. A questo punto si puo decidere di risolverseli a mano oppure di utilizzare un framework. La scelta dipende dagli skill del team e dal grado di complessità dell&#8217;object model e del db. Promuovere l&#8217;idea che un framework non sia necessario è azzardato quanto promuovere l&#8217;idea che sia necessario.</p>
<p>“abbiamo bisogno di un MVC”<br />
Concordo che sia una assunzione sbagliata. Il processo magari potrebbe essere &#8220;dobbiamo garantire una certa qualità&#8221; =&gt; &#8220;il PATTERN MVC è un buon approccio&#8221;. La scelta della implementazione di MVC da usare è quindi una mera scelta di quale implementazione ci torna piu comoda e va fatta in base agli skill del team e alle peculiarità della applicazione. Promuovere l&#8217;idea che un framework non sia necessario è azzardato quanto promuovere l&#8217;idea che sia necessario.</p>
<p>&#8220;i problemi tecnologici che si incontrano in una normale applicazione di tipo gestionale si risolvono bene in maniera incrementale, senza bisogno di framework&#8221;.<br />
Se hai a disposizione un team MOLTO bravo, quello che succede è che, all&#8217;aumentare della complessità del progetto, in maniera incremtale emerga un framework. Ruby on Rails insegna. Se invece il team è SOLO normale, probabilmente all&#8217;aumentare della complessità ti troverai con un mix tra codice applicativo e codice di framework. Dipende dalla qualità del team.</p>
<p>&#8220;Il codice scritto con i framework non è più semplice di quello scritto senza framework&#8221;<br />
Per uno che conosce il DSL di Spring, è molto piu facile capire lo scope di un servizio di quanto non lo sia cercando tutti i &#8220;new&#8221; sparsi nel codice. Dipende dagli skill del team.</p>
<p>Le scelte tecnologice vengono operate in genere all&#8217;inizio di un progetto, fase in cui si hanno a disposizione ben pochi elementi per &#8220;indovinare&#8221;. Proprio per questo, promuovere l&#8217;idea che un framework non sia necessario è azzardato quanto promuovere l&#8217;idea che sia necessario. La cosa migliore in questa incertezza è scegliere la strada in cui il team si sente piu sicuro. E potrebbe essere quella di adottare un Framework oppure no, il punto non è quello.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: matteo				</title>
				<link>http://matteo.vaccari.name/blog/archives/478/comment-page-1#comment-93619</link>
		<dc:creator><![CDATA[matteo]]></dc:creator>
		<pubDate>Sun, 14 Nov 2010 22:35:11 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=478#comment-93619</guid>
					<description><![CDATA[Ciao Gian Marco,

non mi aspetto che questo punto di vista diventi popolare :-)  Anzi va proprio contro il pensare comune, ma non sono convinto che il modo di pensare comune sia il più efficace.

Per rispondere ai tuoi punti: non ti sto incitando a scrivere un tuo framework.  Io penso che dovremmo scrivere codice per risolvere il problema del cliente e scrivere il codice più semplice per risolverlo.  Iniziare lo sviluppo con la solita fase di selezione dei framework non è un passo in quella direzione.  Proprio l&#039;esempio che citi, del framework che fa mapping object-relational, indica che parti dal preconcetto di avere bisogno di un framework per fare mapping object-relational.  Se invece tu partissi a progettare la tua applicazione in maniera incrementale, dal design più semplice, potresti scoprire che non hai bisogno di questo mapping; oppure che puoi ottenere il mapping in maniera più semplice ed efficace senza il framework.

Proprio l&#039;esempio del mio cliente che descrivo nel mio post precedente è di questo tipo: si parte con un preconcetto &quot;abbiamo bisogno di un MVC&quot; e si cerca di martellare tutto per farlo rientrare in un MVC, quando in realtà poi il codice ti dice che ha bisogno di altro.

Il codice scritto con i framework non è più semplice di quello scritto senza framework.  Può sembrarti di avere scritto meno codice, ma questo codice in realtà è fortemente accoppiato al codice dei framework.  Per cui ti ritrovi con codice che apparentemente è più corto, ma non è più semplice da manutenere.  

In pratica nella mia esperienza ho visto che i problemi tecnologici che si incontrano in una normale applicazione di tipo gestionale si risolvono bene in maniera incrementale, senza bisogno di framework.  Le parti tecnologiche più complesse, come ad esempio la crittografia, si risolvono bene usando *librerie* (e non framework.)  Scrivere queste parti &quot;tecnologiche&quot; che si interfacciano a strumenti base esistenti come il database, le API di crittografia o il web server non costa molto.  Il grosso del lavoro lo ha fatto chi ha scritto il web server, il database, o la libreria di crittografia.

Non sono d&#039;accordo che se non ti fai un tuo framework sei costretto al copy-and-paste.  Il &quot;framework personale&quot; è un mostro famigerato perché viene di solito costruito con l&#039;obiettivo sbagliato, cioè con l&#039;obiettivo di fare un framework, con il risultato di infliggere un design che ha funzionato bene una volta ma potrebbe non essere appropriato la seconda.  La ragione giusta per costruirsi un framework è quella di evitare il copy-and-paste, come dici tu, ma questa esigenza non nasce subito.  Prima di arrivare a costruire il tuo framework devi avere cristallizzato la tua conoscenza e la tua comprensione di come si risolve una classe di problemi.  E a questo non ci arrivi la prima volta; magari (cito Francesco Cirillo) ci arrivi la settima volta.  Fino ad allora non ti conviene copiare e incollare la soluzione precedente; ti conviene piuttosto svilupparne una nuova per imparare a fare le cose in maniera un po&#039; diversa.

Lo so che ti sembrerà uno spreco... ma non lo è.  Lo spreco è adattarsi ad usare un framework esistente (e rinunciare ad imparare a risolvere i problemi da solo) oppure cementare in un framework raffazzonato la prima soluzione che hai trovato.





]]></description>
		<content:encoded><![CDATA[<p>Ciao Gian Marco,</p>
<p>non mi aspetto che questo punto di vista diventi popolare :-)  Anzi va proprio contro il pensare comune, ma non sono convinto che il modo di pensare comune sia il più efficace.</p>
<p>Per rispondere ai tuoi punti: non ti sto incitando a scrivere un tuo framework.  Io penso che dovremmo scrivere codice per risolvere il problema del cliente e scrivere il codice più semplice per risolverlo.  Iniziare lo sviluppo con la solita fase di selezione dei framework non è un passo in quella direzione.  Proprio l&#8217;esempio che citi, del framework che fa mapping object-relational, indica che parti dal preconcetto di avere bisogno di un framework per fare mapping object-relational.  Se invece tu partissi a progettare la tua applicazione in maniera incrementale, dal design più semplice, potresti scoprire che non hai bisogno di questo mapping; oppure che puoi ottenere il mapping in maniera più semplice ed efficace senza il framework.</p>
<p>Proprio l&#8217;esempio del mio cliente che descrivo nel mio post precedente è di questo tipo: si parte con un preconcetto &#8220;abbiamo bisogno di un MVC&#8221; e si cerca di martellare tutto per farlo rientrare in un MVC, quando in realtà poi il codice ti dice che ha bisogno di altro.</p>
<p>Il codice scritto con i framework non è più semplice di quello scritto senza framework.  Può sembrarti di avere scritto meno codice, ma questo codice in realtà è fortemente accoppiato al codice dei framework.  Per cui ti ritrovi con codice che apparentemente è più corto, ma non è più semplice da manutenere.  </p>
<p>In pratica nella mia esperienza ho visto che i problemi tecnologici che si incontrano in una normale applicazione di tipo gestionale si risolvono bene in maniera incrementale, senza bisogno di framework.  Le parti tecnologiche più complesse, come ad esempio la crittografia, si risolvono bene usando *librerie* (e non framework.)  Scrivere queste parti &#8220;tecnologiche&#8221; che si interfacciano a strumenti base esistenti come il database, le API di crittografia o il web server non costa molto.  Il grosso del lavoro lo ha fatto chi ha scritto il web server, il database, o la libreria di crittografia.</p>
<p>Non sono d&#8217;accordo che se non ti fai un tuo framework sei costretto al copy-and-paste.  Il &#8220;framework personale&#8221; è un mostro famigerato perché viene di solito costruito con l&#8217;obiettivo sbagliato, cioè con l&#8217;obiettivo di fare un framework, con il risultato di infliggere un design che ha funzionato bene una volta ma potrebbe non essere appropriato la seconda.  La ragione giusta per costruirsi un framework è quella di evitare il copy-and-paste, come dici tu, ma questa esigenza non nasce subito.  Prima di arrivare a costruire il tuo framework devi avere cristallizzato la tua conoscenza e la tua comprensione di come si risolve una classe di problemi.  E a questo non ci arrivi la prima volta; magari (cito Francesco Cirillo) ci arrivi la settima volta.  Fino ad allora non ti conviene copiare e incollare la soluzione precedente; ti conviene piuttosto svilupparne una nuova per imparare a fare le cose in maniera un po&#8217; diversa.</p>
<p>Lo so che ti sembrerà uno spreco&#8230; ma non lo è.  Lo spreco è adattarsi ad usare un framework esistente (e rinunciare ad imparare a risolvere i problemi da solo) oppure cementare in un framework raffazzonato la prima soluzione che hai trovato.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Gian Marco Gherardi				</title>
				<link>http://matteo.vaccari.name/blog/archives/478/comment-page-1#comment-93618</link>
		<dc:creator><![CDATA[Gian Marco Gherardi]]></dc:creator>
		<pubDate>Sun, 14 Nov 2010 15:45:41 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=478#comment-93618</guid>
					<description><![CDATA[Perchè usiamo i framework?
* Spesso nel nostro lavoro il focus è risolvere un problema dell&#039;utente, non risolvere un problema tecnologico. I framework risolvono problemi tecnologici
* Risolvere in maniera ottimale un problema tecnologico è spesso un progetto a se stante (tipo il mapping Object-Relational) e necessita di competenze diverse rispetto a quelle necessarie per risolvere un problema dell&#039;utente
* &quot;The best code is no code at all&quot;: i framework permettono di limitare la quantità di codice da manutenere.
* Spesso i framework implementano una filosofia: utilizzare un framework puo quindi aiutare la consistenza in progetti dove lavorano molte mani

Nel codice riportato nei tuoi esempi a mio avviso quello che stai facendo è semplicemente creare un framework ad-hoc. Se non crei un framework l&#039;unica alternativa è il copy&#038;paste.
Quindi in definitiva il tuo consiglio mi pare sia quello di non usare framework fatti da altri ma di farsi il proprio.

Mi dispiace ma non condivido affatto]]></description>
		<content:encoded><![CDATA[<p>Perchè usiamo i framework?<br />
* Spesso nel nostro lavoro il focus è risolvere un problema dell&#8217;utente, non risolvere un problema tecnologico. I framework risolvono problemi tecnologici<br />
* Risolvere in maniera ottimale un problema tecnologico è spesso un progetto a se stante (tipo il mapping Object-Relational) e necessita di competenze diverse rispetto a quelle necessarie per risolvere un problema dell&#8217;utente<br />
* &#8220;The best code is no code at all&#8221;: i framework permettono di limitare la quantità di codice da manutenere.<br />
* Spesso i framework implementano una filosofia: utilizzare un framework puo quindi aiutare la consistenza in progetti dove lavorano molte mani</p>
<p>Nel codice riportato nei tuoi esempi a mio avviso quello che stai facendo è semplicemente creare un framework ad-hoc. Se non crei un framework l&#8217;unica alternativa è il copy&amp;paste.<br />
Quindi in definitiva il tuo consiglio mi pare sia quello di non usare framework fatti da altri ma di farsi il proprio.</p>
<p>Mi dispiace ma non condivido affatto</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Extreme Enthusiasm » Blog Archive » Framework-free web programming &#187; Web Coding Unravelled				</title>
				<link>http://matteo.vaccari.name/blog/archives/478/comment-page-1#comment-93609</link>
		<dc:creator><![CDATA[Extreme Enthusiasm » Blog Archive » Framework-free web programming &#187; Web Coding Unravelled]]></dc:creator>
		<pubDate>Fri, 12 Nov 2010 10:49:34 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=478#comment-93609</guid>
					<description><![CDATA[[...] here: Extreme Enthusiasm » Blog Archive » Framework-free web programming Related Posts:Extreme Enthusiasm » Blog Archive » Framework-free web programming I presented [...]]]></description>
		<content:encoded><![CDATA[<p>[&#8230;] here: Extreme Enthusiasm » Blog Archive » Framework-free web programming Related Posts:Extreme Enthusiasm » Blog Archive » Framework-free web programming I presented [&#8230;]</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Alessandro Nadalin				</title>
				<link>http://matteo.vaccari.name/blog/archives/478/comment-page-1#comment-93607</link>
		<dc:creator><![CDATA[Alessandro Nadalin]]></dc:creator>
		<pubDate>Fri, 12 Nov 2010 10:35:10 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=478#comment-93607</guid>
					<description><![CDATA[Matteo, consider putting the presentation on slideshare]]></description>
		<content:encoded><![CDATA[<p>Matteo, consider putting the presentation on slideshare</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: matteo				</title>
				<link>http://matteo.vaccari.name/blog/archives/478/comment-page-1#comment-93605</link>
		<dc:creator><![CDATA[matteo]]></dc:creator>
		<pubDate>Fri, 12 Nov 2010 07:55:02 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=478#comment-93605</guid>
					<description><![CDATA[@Maurizio: ti faccio una domanda.  Per che motivo non implementi tu stesso la soluzione nota ai problemi che capitano frequentemente?  Altra domanda: se non &quot;domini il database&quot; allora lasci che sia lui a dominare te?  Non lo dico per fare polemica, sono domande per me importanti.

@Andrea: hai già risposto tu, poi Alberto Brandolini ha fatto un&#039;interessantissima presentazione subito dopo la mia e ha detto la stessa cosa.  Il DDD non funziona se il domain model è &quot;anemico&quot;, cioè si riduce a replicare lo schema dei dati con &quot;oggetti&quot; che in realtà sono solo strutture dati con getter e setter.  

Il problema è che molti leggono il libro del DDD e poi partono a implementare le &quot;entities&quot; come oggetti tristi e i &quot;services&quot; come procedure che lavorano sui dati.  

L&#039;altro problema è che *tutti* i framework Java ti spingono in quella direzione.  OK, Hibernate non dovrebbe essere usato così, per come lo intendevano gli autori originali, ma non so per quale motivo quasi tutti lo usano per ragionare in maniera procedurale.]]></description>
		<content:encoded><![CDATA[<p>@Maurizio: ti faccio una domanda.  Per che motivo non implementi tu stesso la soluzione nota ai problemi che capitano frequentemente?  Altra domanda: se non &#8220;domini il database&#8221; allora lasci che sia lui a dominare te?  Non lo dico per fare polemica, sono domande per me importanti.</p>
<p>@Andrea: hai già risposto tu, poi Alberto Brandolini ha fatto un&#8217;interessantissima presentazione subito dopo la mia e ha detto la stessa cosa.  Il DDD non funziona se il domain model è &#8220;anemico&#8221;, cioè si riduce a replicare lo schema dei dati con &#8220;oggetti&#8221; che in realtà sono solo strutture dati con getter e setter.  </p>
<p>Il problema è che molti leggono il libro del DDD e poi partono a implementare le &#8220;entities&#8221; come oggetti tristi e i &#8220;services&#8221; come procedure che lavorano sui dati.  </p>
<p>L&#8217;altro problema è che *tutti* i framework Java ti spingono in quella direzione.  OK, Hibernate non dovrebbe essere usato così, per come lo intendevano gli autori originali, ma non so per quale motivo quasi tutti lo usano per ragionare in maniera procedurale.</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Andrea Maietta				</title>
				<link>http://matteo.vaccari.name/blog/archives/478/comment-page-1#comment-93604</link>
		<dc:creator><![CDATA[Andrea Maietta]]></dc:creator>
		<pubDate>Fri, 12 Nov 2010 01:42:48 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=478#comment-93604</guid>
					<description><![CDATA[Intanto grazie per la presentazione. Potresti espandere il discorso sul lato oscuro del DDD? Probabilmente nella presentazione dal vivo lo hai anche fatto, ma con le sole slide faccio un po&#039; fatica. Dal mio punto di vista se il domain model si riduce a uno schema dei dati e una serie di procedure in realtà hai un transaction script travestito, non un vero domain model (zio Brando se ci sei batti un colpo). 

Anche se, in realtà, perfino lo stesso uncle Bob dice che ci sono &quot;oggetti&quot; (dati) e &quot;oggetti&quot; (dati e comportamento). Come sempre il confine può diventare labile :-)]]></description>
		<content:encoded><![CDATA[<p>Intanto grazie per la presentazione. Potresti espandere il discorso sul lato oscuro del DDD? Probabilmente nella presentazione dal vivo lo hai anche fatto, ma con le sole slide faccio un po&#8217; fatica. Dal mio punto di vista se il domain model si riduce a uno schema dei dati e una serie di procedure in realtà hai un transaction script travestito, non un vero domain model (zio Brando se ci sei batti un colpo). </p>
<p>Anche se, in realtà, perfino lo stesso uncle Bob dice che ci sono &#8220;oggetti&#8221; (dati) e &#8220;oggetti&#8221; (dati e comportamento). Come sempre il confine può diventare labile :-)</p>
]]></content:encoded>
						</item>
						<item>
				<title>
				By: Maurizio				</title>
				<link>http://matteo.vaccari.name/blog/archives/478/comment-page-1#comment-93603</link>
		<dc:creator><![CDATA[Maurizio]]></dc:creator>
		<pubDate>Fri, 12 Nov 2010 01:37:55 +0000</pubDate>
		<guid isPermaLink="false">http://matteo.vaccari.name/blog/?p=478#comment-93603</guid>
					<description><![CDATA[Molto interessante, in molti punti condivido le tue idee, soprattutto in ambito &quot;piccoli progetti&quot;. Ma quando la complessità del progetto cresce i framework ti danno quella marcia in più, ti permettono di condividere convenzioni conosciute, dandoti per definizione soluzione a dei problemi già noti.

Concordo sul passaggio di moda, è un aspetto deleterio, a cui oramai nel bene o nel male ho fatto il callo. Per quanto riguarda errori e feature, un fw sufficientemente maturo (magari con una comunità OS attiva, personalmente non mi inalbererei mai su uno proprietario tipo dotnet o simili) non dovrebbe soffrire di questi inconvenienti.

Pienamente d&#039;accordo sull&#039;utilizzo degli oggetti e dei pattern, a prescindere se si utilizzino fw o meno. Del resto il domain model, nell&#039;ottica di un corretto design, non dovrebbe mai essere manipolato direttamente (a questo servono i dao, i dto, i controller, etc.).

La logica dei repository ti porterebbe a scrivere codice su codice per le relazioni n:m, a dovere gestire lazy o eager collection, etc.

D&#039;accordo anche sulle performance: oggi tra MVC framework, Dependency Injection, ORM, etc. non è difficile arrivare a tempi di deploy di 5 minuti (anche se una buona adozione di TDD limita sensibilmente questi inconvenienti).

In passato ho provato a dominare i DB, ma è una procedura troppo prona agli errori, soprattutto quando si sviluppa in team (troppe convenzioni custom da dover ricordare). Oltretutto il livello di astrazione di un ORM disaccoppia l&#039;applicazione dal DB, aumentandone la portabilità.

La generazione dell&#039;HTML è quella su cui mi trovi meno d&#039;accordo, in queste slide si intravedono le tag library e i component dei principali MVC.

In definitiva perché utilizzare i FW? Beh, la prima cosa che mi viene in mente è: per evitare di reinventare la ruota ogni giorno.  

Chiaramente sono solo i miei 2 cent, piuttosto ti faccio i complimenti per l&#039;analisi che hai svolto.]]></description>
		<content:encoded><![CDATA[<p>Molto interessante, in molti punti condivido le tue idee, soprattutto in ambito &#8220;piccoli progetti&#8221;. Ma quando la complessità del progetto cresce i framework ti danno quella marcia in più, ti permettono di condividere convenzioni conosciute, dandoti per definizione soluzione a dei problemi già noti.</p>
<p>Concordo sul passaggio di moda, è un aspetto deleterio, a cui oramai nel bene o nel male ho fatto il callo. Per quanto riguarda errori e feature, un fw sufficientemente maturo (magari con una comunità OS attiva, personalmente non mi inalbererei mai su uno proprietario tipo dotnet o simili) non dovrebbe soffrire di questi inconvenienti.</p>
<p>Pienamente d&#8217;accordo sull&#8217;utilizzo degli oggetti e dei pattern, a prescindere se si utilizzino fw o meno. Del resto il domain model, nell&#8217;ottica di un corretto design, non dovrebbe mai essere manipolato direttamente (a questo servono i dao, i dto, i controller, etc.).</p>
<p>La logica dei repository ti porterebbe a scrivere codice su codice per le relazioni n:m, a dovere gestire lazy o eager collection, etc.</p>
<p>D&#8217;accordo anche sulle performance: oggi tra MVC framework, Dependency Injection, ORM, etc. non è difficile arrivare a tempi di deploy di 5 minuti (anche se una buona adozione di TDD limita sensibilmente questi inconvenienti).</p>
<p>In passato ho provato a dominare i DB, ma è una procedura troppo prona agli errori, soprattutto quando si sviluppa in team (troppe convenzioni custom da dover ricordare). Oltretutto il livello di astrazione di un ORM disaccoppia l&#8217;applicazione dal DB, aumentandone la portabilità.</p>
<p>La generazione dell&#8217;HTML è quella su cui mi trovi meno d&#8217;accordo, in queste slide si intravedono le tag library e i component dei principali MVC.</p>
<p>In definitiva perché utilizzare i FW? Beh, la prima cosa che mi viene in mente è: per evitare di reinventare la ruota ogni giorno.  </p>
<p>Chiaramente sono solo i miei 2 cent, piuttosto ti faccio i complimenti per l&#8217;analisi che hai svolto.</p>
]]></content:encoded>
						</item>
			</channel>
</rss>
